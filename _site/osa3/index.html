<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Osa 3</title>
  <meta name="description" content="">

  <link rel="stylesheet" href="/assets/main.css">
  <link rel="canonical" href="http://localhost:4000/osa3/">
  <link rel="alternate" type="application/rss+xml" title="Ohjelmistotuotanto avoin yliopisto 2020" href="/feed.xml">

  
</head>


  <body>
    
    <header class="site-header" role="banner">

  <div class="wrapper">
    
    
    <a class="site-title" href="/">Ohjelmistotuotanto avoin yliopisto 2020</a>
    
    
      <nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
              <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
              <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger">
          
            
            
          
            
            
          
            
            
          
            
            
          
            
            
          
            
            
          
            
            
          
            
            
          
            
            
            <a class="page-link" href="/osa0/">Osa 0</a>
            
          
            
            
            <a class="page-link" href="/osa1/">Osa 1</a>
            
          
            
            
            <a class="page-link" href="/osa2/">Osa 2</a>
            
          
            
            
            <a class="page-link" href="/osa3/">Osa 3</a>
            
          
            
            
            <a class="page-link" href="/osa4/">Osa 4</a>
            
          
            
            
            <a class="page-link" href="/osa5/">Osa 5</a>
            
          
            
            
          
            
            
          
            
            
          
            
            
          
            
            
            <a class="page-link" href="/tehtavat/">Tehtävät</a>
            
          
            
            
          
            
            
          
            
            
          
            
            
          
            
            
          
            
            
          
            
            
          
            
            
          
            
            
          
          
        </div>
      </nav>
    

    
  </div>
</header>


    <main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post">

  <header class="post-header">
    <h1 class="post-title">Ohjelmistojen laadunhallinta</h1>
  </header>

  <div class="post-content">
    <p><a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/">
  <img alt="Creative Commons -lisenssi" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/3.0/88x31.png" />
</a></p>

<p>Tässä osassa tutustumme ohjelmistojen laadunhallintaan ja erityisesti ketterien menetelmien suosimiin testauksen ja laadunhallinnan menetelmiin.</p>

<h2 id="typoja-materiaalissa">Typoja materiaalissa</h2>

<p>Tee <a href="/osa0#typoja-materiaalissa">korjausehdotus</a> editoimalla <a href="https://github.com/ohjelmistotuotanto-hy/ohjelmistotuotanto-hy.github.io/blob/master/osa3.md">tätä</a> tiedostoa GitHubissa.</p>

<h2 id="laadunhallinnan-peruskysymykset-verifiointi-ja-validointi">Laadunhallinnan peruskysymykset: verifiointi ja validointi</h2>

<p>Ohjelmiston laadunhallintaan liittyy oleellisena asiana <em>verifiointi</em> ja <em>validointi</em>.</p>

<p><em>Verifioinnissa</em> pyritään varmistamaan, että ohjelmisto toteuttaa vaatimusmäärittelyn aikana sille asetetut vaatimukset. Yleensä tämä tapahtuu testaamalla, että ohjelma toteuttaa vaatimusmäärittelyyn kirjatut toiminnalliset ja ei-toiminnalliset vaatimukset. Verifiointi siis pyrkii vastaamaan kysymykseen <em>are we building the product right</em>.</p>

<p>Validointi taas pyrkii varmistamaan, että ohjelmisto täyttää käyttäjän odotukset ja tarpeet. Vaatimusmäärittelyn aikana kirjatut ohjelmiston vaatimukset eivät ole aina se mitä käyttäjä todella tarvitsee. Validointiin liittyvä oleellinen kysymys onkin <em>are we building the right product</em>, eli ollaanko ylipäätään tekemässä oikeaa järjestelmää kulloiseenkin käyttötarkoitukseen.</p>

<p>Verifioinnin ja validoinnin tavoitteena on varmistaa, että ohjelma on “riittävän hyvä” siihen käyttötarkoitukseen, mihin ohjelma on tarkoitettu. Hyvyys on suhteellista ja riippuu ohjelman käyttötarkoituksesta. Ohjelman ei tarvitse yleensä olla täysin virheetön ollakseen kuitenkin riittävän hyvä käyttötarkoitukseensa.</p>

<p>Verifioinnin ja validoinnin suorittamista käytetään yleisesti nimitystä <em>laadunhallinta</em> (engl. quality assurance, QA). Jos laadunhallinta on erillisen tiimin vastuulla, käytetään tästä usein nimitystä QA-tiimi.</p>

<h2 id="laadunhallinnan-tekniikat">Laadunhallinnan tekniikat</h2>

<p>Perinteisesti laadunhallinnassa on käytetty kahta erihenkistä tekniikkaa, katselmointeja/tarkastuksia sekä testausta.</p>

<p><em>Katselmoinnissa</em> (engl. review) käydään läpi ohjelmiston tuotantoprosessin aikana syntyneitä dokumentteja sekä ohjelmakoodia, ja etsitään näistä erilaisia ongelmia.</p>

<p>Tarkastukset taas (engl. inspection) ovat katselmoinnin muodollisempi versio. 
Tarkastus suoritetaan järjestämällä formaali kokous, jolla on tarkkaan määritelty agenda ja kokouksen osallistujilla ennalta määritellyt roolit. Tarkastukset kuuluvat vesiputousmallin maailmaan ja eivät ole nykyään suosiossa lukuunottamatta turvallisuuskriittisten järjestelmien kehitystä.</p>

<p>Katselmointi on <em>staattinen tekniikka</em>, suorituskelpoista ohjelmakoodia ei välttämättä tarvita, ja jos katselmoinnin kohteena on ohjelmakoodi, ei ohjelmaa katselmoitaessa yleensä suoriteta.</p>

<p>Testaus taas on <em>dynaaminen tekniikka</em>, joka edellyttää aina ohjelmakoodin suorittamista. Testauksessa tarkkaillaan, miten ohjelma reagoi annettuihin testisyötteisiin.</p>

<h2 id="vaatimusten-validointi">Vaatimusten validointi</h2>

<p>Validointi siis vastaa kysymykseen, ollaanko tekemässä asiakkaan tarpeiden kannalta oikeanlaista järjestelmää.</p>

<p>Ohjelmistolle määritellyt vaatimukset onkin validoitava, eli on varmistettava, että määrittelydokumentti kuvaa sellaisen ohjelmiston, joka vastaa asiakkaan tarpeita.</p>

<p>Vesiputousmallissa määrittelydokumenttiin kirjattujen vaatimusten validointi suoritetaan nimenomaan katselmoimalla. Vaatimusmäärittely päättyy siihen, että asiakas katselmoi määrittelydokumentin ja varmistaa näin, että kirjatut vaatimukset vastaavat asiakkaan mielikuvaa tilattavasta järjestelmästä. Vesiputousmallia sovellettaessa määrittelydokumentti jäädytetään katselmoinnin jälkeen ja sen muuttaminen vaatii yleensä monimutkaista prosessia, ja saattaa edellyttää uutta sopimusta asiakkaan ja sovelluksen toimittajan kesken.</p>

<p>Ketterässä ohjelmistotuotannossa vaatimusten validointi tapahtuu iteraation päättävien demonstraatioiden (Scrumissa sprint reviewin) yhteydessä.</p>

<p>Asiakkaalle näytetään toimivaa versiota ohjelmistosta ja asiakas voi itse verrata, vastaako lopputulos sitä mitä asiakas lopulta haluaa. Asiakkaan tarvitsema toiminnallisuushan voi poiketa ennen iteraatiota määritellystä toiminnallisuudesta ja/tai ohjelmistokehittäjät saattavat tulkita väärin user storyjen kuvaamia vaatimuksia.</p>

<p>Jos asiakas havaitsee, että sovellus ei ole etenemässä haluttuun suuntaan, eli kirjatut vaatimukset eivät vastannet todellista tarvetta, tarve on muuttunut tai vaatimuksia on tulkittu väärin, on seuraavassa iteraatiossa mahdollista ottaa korjausliike.</p>

<p>On ilmeistä, että ketterän mallin käyttämä vaatimusten validointitapa toimii paremmin tuotekehitystä muistuttavissa tilanteissa, joissa ollaan tekemässä tuotetta, joka on vaikea määritellä tarkkaan etukäteen.</p>

<h2 id="koodin-katselmointi">Koodin katselmointi</h2>

<p>Koodin katselmointi eli koodin lukeminen jonkun muun, kuin ohjelmoijan toimesta on havaittu erittäin tehokkaaksi keinoksi koodin laadun parantamisessa. Katselmoinnin avulla voidaan havaita koodista ongelmia, joita on vaikea havaita testaamalla, esim. noudattaako koodi sovittua tyyliä ja onko koodi ylläpidettävää.</p>

<p>Koodin katselmoinnissa on perinteisesti käyty koodia läpi varmistaen, että koodista ei löydy erilaisissa “checklisteissä” lueteltuja riskialttiita piirteitä. Esimerkiksi eräs c-kielisten ohjelmien katselmoinnin checklist löytyy <a href="http://www.oualline.com/talks/ins/inspection/c_check.html">täältä</a>. Joissakin kielissä, esim. Javassa kääntäjän tekemät tarkastukset tekevät osan linkin takana olevan listan tarkistuksista turhaksi.</p>

<p>Nykyään on useita paljon katselmointia automatisoivia <em>staattista analyysiä</em> tekeviä työkaluja, esimerkiksi Javan <a href="http://checkstyle.sourceforge.net/">Checkstyle</a>, johon tutustuttiin jo viikon 2 laskareissa.</p>

<h3 id="staattinen-analyysi-pilvessä">Staattinen analyysi pilvessä</h3>

<p>Pilvipalvelut ovat helpottaneet sovelluskehittäjien työtä monissa asioissa, esim. GitHubin ansiosta omaa versionhallintapalvelinta ei ole enää tarvinnut ylläpitää vuosiin.</p>

<p>Pilveen on viime aikoina ilmestynyt myös koodille staattista analyysiä tekeviä palveluita, esimerkiksi viime viikon laskareissa käytetty <a href="https://codeclimate.com/">Codeclimate</a>, joka analysoi koodista mm. seuraavia asioita:</p>
<ul>
  <li>liian kompleksiset metodit ja luokat</li>
  <li>copy paste -koodi</li>
  <li>testaamaton koodi</li>
</ul>

<p>Codeclimate antaa parannusehdotuksia huomaamistaan epäkohdista ja antaa jopa aika-arvion sille, kuinka kauan kunkin ongelmakohdan korjaamiseen menisi.</p>

<p>Codeclimate myös huomauttaa koodin laadun muutoksista, esim. jos koodin kompleksisuus kasvaa muutosten yhteydessä.</p>

<p>Minkä tahansa GitHubissa olevan projektin saa konfiguroitua Codeclimaten tarkastettavaksi nappia painamalla. Codeclimate suorittaa tarkastukset koodille aina kun uutta koodia pushataan GitHubiin.</p>

<p>Laitoksen harjoitustyökursseilla käytettävän Labtoolin vanhan version <a href="https://codeclimate.com/github/mluukkai/labtool">Codeclimate-raportti</a> kertoo, että koodista löytyy yhteensä 22 epäilyttävää kohtaa. Koodin laadun saama arvosana on <em>C</em> ja arvio sen siistimiseen kuluvasta ajasta on viikko:</p>

<p><img src="http://localhost:4000/images/3-21.png" alt="" height="350px" /></p>

<p>Codeclimate erittelee jokaisen ongelman, ja antaa aika-arvion sille kuinka kauan virheen korjaamiseen menisi aikaa:</p>

<p><img src="http://localhost:4000/images/3-22.png" alt="" height="350px" /></p>

<p>Vastaavia palveluita on nykyään useita, mm. <a href="https://codebeat.co/">Codebeat</a> ja <a href="https://www.codacy.com/">Codacy</a>.</p>

<h3 id="koodin-katselmointi-github-ja-pull-requestit">Koodin katselmointi: GitHub ja pull requestit</h3>

<p>Yhä enenevä määrä ohjelmistokehitysprojekteista tallettaa sovelluksen lähdekoodin GitHubiin. GitHubin <em>pull requestit</em> tarjoavatkin hyvän ja paljon käytetyn työkalun koodikatselmointien tekoon.</p>

<p>Pull requesteja käytettäessä työn kulku on seuraava:</p>
<ul>
  <li>Sovelluskehittäjä forkkaa repositorion itselleen, tekee muutokset omaan repositorioon ja tekee pull requestin projektia hallinnoivalle taholle.</li>
  <li>Hallinnoija, esimerkiksi tiimin “senior developer” tai open source -projektin vastaava tekee katselmoinnin pull requestille.</li>
  <li>Jos koodi ei ole vielä siinä kunnossa, että tehdyt muutokset voidaan liittää repositorioon, kirjoittaa hallinnoija pull requestin tekijälle joukon parannusehdotuksia.</li>
  <li>Muutosten ollessa hyväksyttävästi tehtyjä, pull request mergetään eli yhdistetään päärepositorioon.</li>
</ul>

<p>Seuraavassa esimerkki <a href="https://tmc.mooc.fi/">TMC-projektiin</a> tehdystä pull requestista ja siihen liittyvistä kommenteista:</p>

<p><img src="http://localhost:4000/images/3-1.png" alt="" height="350px" /></p>

<p>Pull requestin kommentissa <a href="https://github.com/kennyhei/">sovelluskehittäjä</a> toteaa, että pull requestin sisältämät commitit toteuttavat <a href="https://github.com/testmycode/tmc-server/issues/185">tämän</a> GitHub-issuen kuvaaman toiminnallisuuden.</p>

<p><img src="http://localhost:4000/images/3-2.png" alt="" height="500px" /></p>

<p>TMC:n silloinen <a href="https://github.com/mpartel/">pääkehittäjä</a> ei kuitenkaan hyväksy muutoksia vielä mergettäväksi, vaan antaa muutaman parannusehdotuksen sovelluskehittäjälle.</p>

<p>Nykyään moni ohjelmistokehitystiimi käyttää säännöllisesti pull requesteja ja on jopa kirjannut definition of doneen, että eräs valmiin kriteeri koodille on se, että joku muu kuin ohjelmoija on katselmoinut sen. Katselmoija voi olla joko toinen sovelluskehittäjä, tai aloittelevien koodareiden tapauksessa joku hieman seniorimpi tiimin jäsen.</p>

<h2 id="koodin-katselmointi-ketterissä-menetelmissä">Koodin katselmointi ketterissä menetelmissä</h2>

<p>Toisin kuin Scrum, erityisesti 2000-luvun alkuvuosina erittäin suosittu ketterä menetelmä <a href="http://www.extremeprogramming.org/">eXtreme Programming </a> eli XP määrittelee useita ohjelmiston kehittäjän työskentelyyn kantaa ottavia käytänteitä.</p>

<p>Suurin osa XP:n käytänteistä on jo vuosikymmeniä hyvin tunnettuja <em>parhaita käytänteitä</em> (engl. best practices), mutta kuitenkin usein vietynä äärimmäiseen (extreme) muotoon. Osa XP:n käytänteistä tähtää ohjelmiston laadun maksimoimiseen, ja muutama palvelee samaa funktiota kuin koodin katselmointi.</p>

<p><em>Pariohjelmoinnissa</em> (engl. pair programming) kaksi ohjelmoijaa työskentelee yhdessä käyttäen ainoastaan yhtä konetta. Koodia kirjoittava osapuoli toimii <em>ohjaajana</em> (engl. driver) ja toinen <em>navigoijana</em> (engl. navigator), roolia vaihdetaan sopivin väliajoin. Navigoija tekee koodiin <em>jatkuvaa katselmointia</em>.</p>

<p>Pariohjelmointi parantaa ohjelmoijien kuria ja työhön keskittymistä sekä on erinomainen oppimisen väline: parit oppivat toisiltaan, erityisesti noviisit kokeneemmilta. Jos pariohjelmointia sovelletaan systemaattisesti, ei koodiin jää osa-alueita, jotka ainoastaan yksi ohjelmoija tuntee.</p>

<p>Tutkimuksissa pariohjelmoinnin on todettu vähentävän bugien määrää 15-50%, kokonaisuudessa resurssien kulutus kuitenkin nousee hieman.</p>

<p>Vaikka pariohjelmointi tai jopa useamman ihmisen versio siitä, <a href="https://en.wikipedia.org/wiki/Mob_programming">mob-programming</a> on melko suosittua, ei kovin monissa paikoissa kuitenkaan harrasteta systemaattisesti määritelmän mukaista pariohjelmointia ainakaan joka päivä. Hyvin yleistä on, että kehittäjät työskentelevät suurimman osan aikaa yksin, mutta tekevät sopivin paikoin spontaaneja pari- tai mob-ohjelmointisessioita, erityisesti kohdatessaan teknisiä haasteita.</p>

<p>Pariohjelmoinnin ohella katselmoinnin kaltaisia tavoitteita koodin laadun nostajana voidaan ajatella olevan XP:n yhteisomistajuuden ja ohjelmointistandardien periaatteilla.</p>

<p>Koodin <em>yhteisomistajuus</em> (engl. collective code ownership) tarkoittaa periaatetta, jossa kukaan yksittäinen ohjelmoija ei hallitse yksin mitään kohtaa koodista, eli kaikilla on lupa tehdä muutoksia ja laajennuksia mihin tahansa kohtaan koodia. Pariohjelmointi tukee yhteisomistajuutta.</p>

<p>Yhteisomistajuudessa on omat riskinsä: joku koodia kunnolla tuntematon voi saada huolimattomilla muutoksilla pahaa jälkeä aikaan. XP pyrkii eliminoimaan tästä aiheutuvia riskejä testaukseen liittyvillä käytänteillä, eli käytännössä automatisoiduilla regressiotesteillä.</p>

<p><em>Ohjelmointistandardi</em> (engl. coding standards) tarkoittaa, että tiimi määrittelee koodityylin, johon kaikki ohjelmoijat sitoutuvat. Tyylillä tarkoitetaan nimeämiskäytäntöä, koodin muotoilua ja myös tiettyjä ohjelman rakenteeseen liittyviä seikkoja. Ohjelmointistandardin noudattamista voidaan kontrolloida osittain automaattisesti staattisen analyysin työkaluilla, esimerkiksi Javan Checkstyle sekä Javascript-maailman <a href="https://eslint.org/">eslint</a> ja <a href="https://prettier.io/">prettier</a> ovat työkaluja, joiden avulla voidaan seurata, että koodi seuraa määriteltyä ohjelmointistandardia. Eräs esimerkki suosituksi nousseesta ohjelmointistandardista on <a href="https://eslint.org/">AirBnB</a>:n tyyliopas.</p>

<h2 id="testaus">Testaus</h2>

<p>Ohjelmistojen osoittaminen virheettömäksi on käytännössä mahdotonta, sillä ohjelmiston mahdollisten käyttöskenaarioiden ja syötteiden kombinaatio on yksinkertaisesti liian suuri. Testauksen tarkoituksena onkin vakuuttaa asiakas ja järjestelmän kehitystiimi siitä, että ohjelmisto on riittävän hyvä käytettäväksi.</p>

<p>Testauksella on kaksi hieman eriävää tavoitetta. Ensinnäkin tulee <em>osoittaa, että ohjelmisto täyttää sille asetetut vaatimukset</em>. Käytännössä tämä tarkoittaa vaatimusmäärittelyssä kirjattujen asioiden toteutumisen demonstroimista toteutusta ohjelmista. Toinen tavoite on <em>löytää ohjelmistosta virheitä</em> eli testatessa yritetään ohjelma rikkoa tai saattaa se jollain tavalla epäkonsistenttiin tilaan. Näin havaitut viat pyritään korjaamaan ennen kuin todelliset käyttäjät törmäävät samoihin ongelmiin.</p>

<p>Molemmat näistä tavoitteista tähtäävät ensisijaisesti ohjelman <em>ulkoisen laadun</em> (engl. external quality) eli käyttäjän kokeman laadun varmistamiseen. <a href="http://c2.com/cgi/wiki?InternalAndExternalQuality">Ulkoisella laadulla</a> tarkoitetaan sitä, onko ohjelmisto sopiva käyttötarkoitukseensa, eli pystyykö käyttäjä tekemään ohjelmistolla haluamansa asiat.</p>

<h2 id="testauksen-tasot">Testauksen tasot</h2>

<p>Testausta jakaantuu eri <em>tasoihin</em> sen mukaan mukaan, mikä testauksen ensisijaisena kohteena on. Ohjelmiston elinkaarta vesiputousmaisesti kuvaava <em>testauksen V-malli</em> havainnollistaa testauksen eri tasoja.</p>

<p><img src="http://localhost:4000/images/3-3.png" alt="" height="300px" /></p>

<p>Alimmalla tasolla on <em>yksikkötestaus</em> (engl. unit testing), jossa tarkastellaan yksittäisten luokkien, metodien ja moduulien toimintaa, yleensä erillään muusta kokonaisuudesta. Yksikkötestauksen hoitavat sovelluskehittäjät.</p>

<p><em>Integraatiotestaus</em> (engl. integration testing) taas sisältää yksittäisistä komponenteista koostettujen kokonaisuuksien toiminnallisuuden testaamisen. Myös integraatiotestauksesta huolehtivat sovelluskehittäjät.</p>

<p><em>Järjestelmätestauksessa</em> (engl. system testing) varmistetaan, että ohjelmisto kokonaisuudessaan toimii vaatimuksiin kirjatulla tavalla. Ohjelmistoa testataan saman rajapinnan kautta, jonka kautta käyttäjät sitä käyttävät. Järjestelmätestauksesta on useimmiten vastuussa ohjelmiston kehittäjäorganisaation laadunhallinnasta vastaavat ihmiset.</p>

<p>Ohjelmiston tilaaja- tai käyttäjäorganisaation tekemää testausta kutsutaan <em>käyttäjän hyväksymistestaukseksi</em> (engl. user acceptance testing), ja sen on tarkoitus varmistaa, että kehitetty ohjelmisto on varmasti odotuksien mukainen ja toimii oikeassa käytössä. Hyväksymistestaus tapahtuu monesti normaalissa tuotantokäytössä ohjelmiston tilanneen organisaation tai loppukäyttäjien toimesta, esim. betatestaamalla sovellusta pienen käyttäjäjoukon avulla.</p>

<h2 id="järjestelmätestaus">Järjestelmätestaus</h2>

<p>Järjestelmätestauksen tarkoitus on siis varmistaa, että ohjelmisto toimii vaatimusmäärittelyssä kirjatulla tavalla. Sovellusta testataan useimmiten saman rajapinnan kautta, jonka kautta sitä käytetään, eli testaus voi tapahtua esimerkiksi graafisen käyttöliittymän kautta.</p>

<p>Järjestelmätestaus tapahtuu ilman tietoa järjestelmän sisäisestä rakenteesta, tälläistä testauksen tapaa nimitetään <em>black box</em> -testaukseksi.</p>

<p>Yleensä järjestelmätestaus perustuu sovelluksen potentiaalisiin käyttöskenaarioihin. Jos vaatimukset on ilmaistu user storyina, on storyjen hyväksymiskriteereistä melko helppo muotoilla testejä, joiden avulla voidaan varmistaa, että ohjelmistolla on storyjen kuvaamat vaatimukset sekä tyypilliset virheskenaariot.</p>

<p>Sovelluksen toiminnallisuutta kartoittavan järjestelmätestauksen (jota joskus kutsutaan <a href="https://en.wikipedia.org/wiki/Functional_testing">funktionaaliseksi testaamiseksi</a>) lisäksi on olemassa paljon <a href="https://en.wikipedia.org/wiki/System_testing">muitakin</a> järjestelmätestauksen muotoja, mm.</p>

<ul>
  <li>käytettävyystestaus</li>
  <li>suorituskykytestaus</li>
  <li>tietoturvan testaus</li>
</ul>

<p>Järjestelmätestaus tapahtuu pääosin kehittäjäorganisaation toimesta. Joissain tapauksissa esim.  tietoturvan tai suorituskyvyn testaaminen saatetaan antaa niihin erikoistuneiden tahojen vastuulle.</p>

<h2 id="testitapausten-valinta">Testitapausten valinta</h2>

<p>Täysin kattava testaaminen on mahdotonta ja testaus on joka tapauksessa työlästä, eli onkin tärkeää löytää kohtuullisen kokoinen testitapausten joukko, jonka avulla on kuitenkin mahdollista löytää mahdollisimman suuri määrä virheitä.</p>

<p>Yksittäinen <em>testitapaus</em> (engl. test case) testaa järjestelmän toiminnallisuutta jollain syötearvolla, tai arvojen kombinaatiolla jos toiminnallisuus edellyttää usean syötteen antamista. Monet syötteistä ovat järjestelmän toiminnan kannalta samanlaisia. Esimerkiksi, jos henkilötietoja käsittelevä järjestelmä tallettaa henkilön iän, on todennäköistä, että järjestelmän toiminta ei poikkea ollenkaan sen suhteen, onko ikä 20 tai 30, mutta jos ikä taas on 17, saattaa järjestelmän toiminnallisuus olla erilainen kuin iän ollessa vähintään 18.</p>

<p>Testeissä kannattaakin pyrkiä jakamaan syötteet <em>ekvivalenssiluokkiin</em>, eli ryhmiin joihin kuuluvien syötteiden suhteen ohjelma toimii oleellisesti samalla tavalla. Testitapauksia kannattaa tehdä useimmiten ainoastaan yksi tai kaksi kutakin ekvivalenssiluokkaa tai syötteiden ekvivalenssiluokkien kombinaatiota kohti. Ekvivalenssiluokkien edustajiksi kannattaa erityisesti valita ekvivalenssiluokkien <em>raja-arvoja</em>, koodissa olevat bugit nimittäin liittyvät erittäin usein toisto- ja ehtolauseiden ehtojen äärimmäisiin arvoihin.</p>

<p>Esimerkiksi henkilötietoja käsittelevässä järjestelmässä iän suhteen ekvivalenssiluokkia olisivat ehkä <em>alaikäinen</em> 0-17 vuotta, <em>työikäinen</em> 18-65 vuotta ja <em>eläkeläinen</em> 66- vuotta. Ekvivalenssiluokkien raja-arvojen järkevä määrittely tosin edellyttää tietoa järjestelmän toiminnallisuudesta. Todennäköisesti työikäisten ja eläkeläisien suhteen ei olisi mahdollista tehdä selkeää jakoa iän perusteella. Jos oletetaan, että edelliset ekvivalenssiluokat olisivat järkeviä, sopivat iän <em>raja-arvot</em> testitapauksia varten olisivat 17, 18, 65 ja 66 vuotta, eli näitä kaikkia kohti voitaisiin tehdä oma testitapauksensa.</p>

<p>Tarkastellaan toisena esimerkkinä tekstitv:n selainversiota.</p>

<p><img src="http://localhost:4000/images/3-4.png" alt="" height="450px" /></p>

<p>Mitä testitapauksia kannattaisi valita tekstitv:n sivun valintaikkunan toimivuuden testaamisessa?</p>

<p>Tekstitv:n sivu vastaa lukua väliltä 100-899. Osaa välin luvuista vastaavaa sivua ei kuitenkaan ole olemassa.</p>

<p>Syötteen ekvivalenssiluokkia olisivat ainakin seuraavat:</p>
<ul>
  <li>olemassa olevaa sivua vastaavat luvut</li>
  <li>validit luvut, jotka eivät vastaa mitään sivua</li>
  <li>liian pienet ja liian suuret luvut</li>
  <li>syötteet, jotka sisältävät kiellettyjä merkkejä esimerkiksi aakkosia</li>
  <li>tyhjä syöte</li>
</ul>

<p>Jos testeistä halutaan kattavat, olisi jokaisesta ekvivalenssiluokasta hyvä valita ainakin yksi testattava syötearvo.</p>

<p>Olemassa olevaa sivua vastaavan ekvivalenssin rajatapaukset, eli luvut 100 ja 899 kannattaisi ehkä valita testisyötteiksi, samoin luvut 99 ja 900, jotka ovat oman ekvivalenssiluokkansa rajatapauksia.</p>

<h2 id="yksikkötestaus">Yksikkötestaus</h2>

<p>Yksikkötestauksen kohteena siis ovat yksittäiset metodit ja luokat. Yksikkötestauksen hoitavat ohjelmoijat, usein oletetaan että uuteen koodiin tehdään yksikkötestit jo samalla kuin koodi kirjoitetaan. Ohjelmoijien vastuulla olevasta testauksesta, eli yksikkö- ja integraatiotestauksesta käytetään usein nimitystä <a href="https://developertesting.rocks/">developer testing</a>.</p>

<p>Yksikkötestejä laadittaessa otetaan huomioon testattavan koodin rakenne, esimerkiksi minkälaisia ehtolauseita koodissa on käytetty. Tälläisistä testeistä käytetään usein nimitystä <em>lasilaatikkotestaus</em> (engl. white box testing).</p>

<p>Yksikkötestauksella ei testata suoranaisesti sitä, täyttääkö ohjelmisto käyttäjän sille asettamat vaatimukset, pikemminkin tavoitteena on ohjelman <em>sisäisen laadun</em> (engl. internal quality) kontrollointi. <a href="http://c2.com/cgi/wiki?InternalAndExternalQuality">Sisäinen laatu</a> viittaa koodin sisäisen rakenteen hyvyyteen: onko koodia helppo jatkokehittää, onko virheiden jäljitys ja korjaaminen helppoa ja pystytäänkö koodin toiminnallisuuden oikeellisuus varmistamaan muutoksia tehtäessä.</p>

<p>Sisäinen laatu kiinnostaa ensisijaisesti ohjelmistokehittäjiä: jos koodi on sisäiseltä laadultaan heikkoa, on sen parissa työskenteleminen ikävää ja hidasta. Jos koodin sisäinen laatu alkaa rapistua, sovelluksen kehitystahti hidastuu, ja ohjelmistoon alkaa todennäköisesti kertymään enenevissä määrin bugeja jotka näkyvät myös loppukäyttäjälle asti.</p>

<p>Pelkkä sisäisen laadun kontrollimekanismi yksikkötestaus ei siis ole. Kattavilla yksikkötesteillä saadaan parannettua myös ohjelman ulkoista, eli asiakkaan kokemaa laatua. Yksikkötestit voivat eliminoida joitain asiakkaalle näkyviä virheitä, joita järjestelmätestauksen testitapaukset eivät löydä.</p>

<p>Tiedetään, että bugit on taloudellisesti edullista paikallistaa mahdollisimman aikaisessa vaiheessa, eli yksikkötestauksessa löydetty virhe on halvempi ja nopeampi korjata kuin integraatio- tai järjestelmätestauksessa löytyvä, tai vasta todellisessa käytössä ilmennyt virhe.</p>

<p>Koska yksikkötestejä joudutaan suorittamaan moneen kertaan, tulee niiden suorittaminen ja testien tulosten raportointi automatisoida, ja nykyinen hyvä työkalutuki tekeekin automatisoinnin helpoksi. Java-maailmasta tuttu jUnit on edelleen yksi suosituimpia testikirjastoja, uudempia tulokkaita ovat mm. rspec, jest, jasmine.</p>

<p>Kurssilla <a href="https://courses.helsinki.fi/fi/tkt20002">Ohjelmistotekniikka</a> tehdyt testit ovat useimmiten juurikin yksikkötestejä.</p>

<h3 id="mitä-ja-miten-paljon-tulee-testata">Mitä ja miten paljon tulee testata?</h3>

<p>Mitä kaikkea ohjelmistosta tulisi testata yksikkötesteillä? Vastaus ei ole helppo. JUnitin alkuperäinen kehittäjä <a href="https://junit.org/junit4/faq.html#best_2">Kent Beck</a> vastaa kysymykseen seuraavasti:</p>

<blockquote>
  <p>“Do I have to write a test for everything?”
“No, just test everything that could reasonably break”</p>
</blockquote>

<p>Jos pyritään kattavaan yksikkötestaukseen, tulisi ainakin testata kaikkien metodien (ja loogisten metodikombinaatioden) toiminta parametrien hyväksyttävillä arvoilla ja virheellisillä parametrien arvoilla.</p>

<p>Parametrien mahdolliset arvot kannattaa jakaa ekvivalenssiluokkiin ja jokaisesta luokasta kannattaa  valita ainakin yksi arvo testisyötteeksi, erityisesti ekvivalenssiluokkien raja-arvot kannattaa valita mukaan testattaviin arvoihin.</p>

<p>Koska yksikkötestejä tehtäessä ohjelmakoodi on nähtävillä, on testien parametrien ekvivalenssiluokat ja raja-arvot useimmiten pääteltävissä koodista.</p>

<p>Tarkastellaan esimerkkinä ensimmäisen viikon laskareista tutun <em>Ohtuvaraston</em> metodia <em>otaVarastosta</em>. Mitä testitapauksia tulisi generoida, jotta testit olisivat kattavat?</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Varasto</span> <span class="o">{</span> 
  <span class="kd">private</span> <span class="kt">double</span> <span class="n">tilavuus</span><span class="o">;</span> 
  <span class="kd">private</span> <span class="kt">double</span> <span class="n">saldo</span><span class="o">;</span>

  <span class="kd">public</span> <span class="kt">double</span> <span class="nf">otaVarastosta</span><span class="o">(</span><span class="kt">double</span> <span class="n">maara</span><span class="o">)</span> <span class="o">{</span> 
    <span class="k">if</span> <span class="o">(</span><span class="n">maara</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="mf">0.0</span><span class="o">;</span>

    <span class="k">if</span><span class="o">(</span><span class="n">maara</span> <span class="o">&gt;</span> <span class="n">saldo</span><span class="o">)</span> <span class="o">{</span>
      <span class="kt">double</span> <span class="n">kaikkiMitaVoidaan</span> <span class="o">=</span> <span class="n">saldo</span><span class="o">;</span> 
      <span class="n">saldo</span> <span class="o">=</span> <span class="mf">0.0</span><span class="o">;</span>
      <span class="k">return</span> <span class="n">kaikkiMitaVoidaan</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="n">saldo</span> <span class="o">=</span> <span class="n">saldo</span> <span class="o">-</span> <span class="n">maara</span><span class="o">;</span>
    <span class="k">return</span> <span class="n">maara</span><span class="o">;</span> 
  <span class="o">}</span>  
<span class="o">}</span>
</code></pre></div></div>

<p>Metodia <em>otaVarastosta</em> testatessa testitapauksessa on huomioitava parametrin <em>maara</em> lisäksi varaston tilanne. Varaston tilanteella on kolme “ekvivalenssiluokkaa”:</p>
<ul>
  <li><em>tyhjä</em> (esim. saldo 0, tilavuus 10)</li>
  <li><em>ei tyhjä eikä täysi</em> (esim. saldo 5, tilavuus 10)</li>
  <li><em>täysi</em> (saldo 10, tilavuus 10).</li>
</ul>

<p>Näitä kutakin kohti on metodin parametrilla <em>maara</em> omat ekvivalenssiluokkansa. Jos varasto on “puolitäysi”, eli saldo on 5, muuttujan <em>maara</em> arvoiksi voitaisiin valita <em>-1, 0, 5, 6</em>. Jos varasto on täysi, muuttujan <em>maara</em> arvoiksi sopisivat <em>-1, 0, 10, 11</em>. Jos varasto on tyhjä, muuttujan <em>maara</em> arvoiksi voidaan valita <em>-1, 0, 1</em>.</p>

<p>Nollan ja negatiivisen määrän ottamista tuskin kannattaa erikseen testata kaikkien varastotilanteiden suhteen, tosin tämäkin voisi olla riski, jos varaston sisäinen toteutus muutettaisiin täysin.</p>

<p>Huomaamme siis, että jo naurettavan pienen luokan yhden metodin kattava testaaminen vaatii suuren määrän testitapauksia. Useimmissa tapauksissa ei ole kuitenkaan ole realisitista olettaa, että testejä tehdään vastaavalla kattavuudella, aika/hyötysuhde on yksinkertaisesti liian huono. Useimmat softassa olevat ikävät bugit jäävät joka tapauksessa yksikkötestauksen ulottumattomiin.</p>

<h3 id="testauskattavuus">Testauskattavuus</h3>

<p>Yksikkötestien (ja toki myös muunlaisten testien) hyvyyttä voidaan mitata <em>testauskattavuuden</em> (engl. test coverage) käsitteellä. Testauskattavuutta on muutamaa eri tyyppiä.</p>

<p><em>Rivikattavuudella</em> (engl. line coverage) tarkoitetaan kuinka montaa prosenttia ohjelman koodiriveistä testitapausten suorittaminen käy läpi. Vaikka rivikattavuus olisi 100% ei tämä tietenkään tarkoita, että kaikki oleellinen toiminnallisuus olisi tutkittu.</p>

<p><em>Haarautumakattavuudella</em> (engl. branch coverage) tarkoitetaan kuinka montaa prosenttia testattavan metodin/luokan sisältävistä ehtolauseiden haaroista testit ovat käyneet läpi.</p>

<p>Monet työkalut, esim. laskareissa käyttämämme JaCoCo mittaavat testien suorituksen yhteydessä testauskattavuuden. Muitakin kattavuuden tyyppejä on olemassa, mm. ehtokattavuus ja polkukattavuus, useat työkalut eivät niitä kuitenkaan tue.</p>

<p><img src="http://localhost:4000/images/3-5.png" alt="" height="350px" /></p>

<p>JaCoCo ilmoittaa sekä rivi- (instruction) että haarautumakattavuuden (branches). Puutteellisesti testattu haarautumiskohta esim. if ilmaistaan keltaisella.</p>

<p>Testauskattavuus toimii siis hyvänä apuvälineenä sen arvioimisessa testataanko sovellusta riittävästi.</p>

<h3 id="mutaatiotestaus">Mutaatiotestaus</h3>

<p>Pelkkä testikattavuus ei kuitenkaan vielä kerro oikeastaan mitään testien hyvyydestä. Hyvät testit ovat  sellaisia, että jos ohjelmaan tulee bugi, huomaavat testit virheen. Testien hyvyys taas riippuu oleellisesti testien syötteiden lisäksi siitä, minkälaisia assert-lauseilla suoritettavia tarkistuksia testeissä on.</p>

<p><em>Mutaatiotestauksen</em> (engl. mutation testing) idea on nimenomaan testata testitapausten hyvyyttä generoimalla koodiin systemaattisesti mutantteja eli pieniä “bugeja”, ja katsoa havaitsevatko testit koodiin tulleet bugit.</p>

<p>Erilaisia mutanttityyppejä, joita mutaatiotestauksessa generoidaan koodiin on paljon mm.</p>

<ul>
  <li>manipuloidaan ehtolausetta: <tt>if ( x&lt;0 )</tt> muutetaan muotoon <tt>if (x &lt;= 0)</tt> tai <tt>if ( true ) </tt></li>
  <li>vaihdetaan operaattoria: <tt>x += 1</tt> muutetaan muotoon <tt>x -= 1</tt></li>
  <li>kovakoodataan paluuarvo: <tt>return x;</tt>  muutetaan muotoon <tt>return true;</tt></li>
  <li>korvataan konstruktorikutsu: <tt>olio = new Olio()</tt>  muutetaan muotoon <tt>olio = null;</tt></li>
</ul>

<p>Mutaatiotestauksen ongelmana on mutaatioiden suuri määrä ja ns. <em>ekvivalentit mutantit</em>, joiden takia mutaatiotestauksen tulos vaatii aina ihmisen tulkintaa.</p>

<p>Ekvivalentti mutantti tarkoittaa sellaista koodiin tehtyä muutosta, joka ei kuitenkaan muuta ohjelman toiminnallisuutta. Eli tälläisen mutantin lisäämistä koodiin ei voi mikään testi havaita. Mutantin toteaminen ekvivalentiksi algoritmisesti on mahdotonta.</p>

<p>Lisätietoa mutaatiotestauksesta esim. <a href="http://en.wikipedia.org/wiki/">wikipediassa</a> ja <a href="http://pitest.org/">pit</a>-työkalun sivulla.</p>

<h2 id="integraatiotestaus">Integraatiotestaus</h2>

<p>Järjestelmän yksittäiset, erillään yksikkötestatut luokat tulee integroida toimivaksi kokonaisuudeksi. Integroinnin yhteydessä tai sen jälkeen suoritetaan integraatiotestaus, missä painopisteenä on ohjelman komponenttien välisten rajapintojen toimivuuden tutkimisessa sekä komponenttien yhdessä tuottaman toiminnallisuuden oikeellisuuden varmistamisessa.</p>

<p>Järjestelmän integrointi voi edetä joko järjestelmän rakenteeseen perustuen tai järjestelmän toteuttamien ominaisuuksien mukaan.</p>

<p><em>Rakenteeseen perustuvassa integraatiossa</em> keskitytään kerrallaan sovelluksen yksittäisten rakenteellisten komponenttien integrointiin, esimerkiksi verkkokaupan toteutuksessa integroitaisiin ensin arkkitehtuurilliset komponentit tai kerrokset, eli sovelluslogiikan luokat, käyttöliittymän toteutus ja tietokantarajapinta omina kokonaisuuksinaan. Tämän jälkeen kerrokset integroitaisiin kokonaiseksi sovellukseksi.</p>

<p><em>Ominaisuuksiin perustuvassa integroinnissa</em> taas liitetään yhteen alikomponentit, jotka toteuttavat järjestelmän loogisen toiminnallisuuden. Verkkokaupassa voitaisiin esimerkiksi integroida kerrallaan kaikki toiminnallisuuteen <em>lisää tuote ostoskoriin</em> liittyvä koodi ja edetä toiminnallisuus kerralla kunnes koko sovellus on valmis.</p>

<p>Vanhan liiton ohjelmistotuotannossa toimintatapa oli se, että kaikki ohjelman yksittäiset komponentit ohjelmoitiin ja yksikkötestattiin erikseen ja tämän jälkeen ne integroitiin (yleensä rakenteeseen perustuen) kerralla yhteen.</p>

<p>Tällainen vesiputousmallin maailmassa yleinen, nimikkeellä <em>big bang</em> -integraatio kulkeva tekniikka on osoittautunut todella riskialttiiksi (siitä on seurauksena usein ns. integraatiohelvetti) ja sitä ei enää kukaan täysijärkinen suosittele käytettäväksi.</p>

<p>Moderni ohjelmistotuotanto suosii ns. <em>jatkuvaa integraatiota</em> (engl. continuous integration), joka on hyvin tiheässä tahdissa tapahtuvaa ominaisuuksiin perustuvaa integrointia. Palaamme aiheeseen tarkemmin pian.</p>

<p>Itseasiassa koko termi <em>integraatiotestaus</em> on käsitteenä melko häilyvä, ja joskus on vaikea tehdä selkeää rajanvetoa yksikkö- ja integraatiotestauksen välillä. Useimmiten ajatellaan että yksikkötestien kohteena on yksittäinen metodi, luokka tai ohjelmamoduuli. Entä jos testauksen alla oleva luokka/moduuli pitää sisällään rajapinnan takana useita muitakin luokkia, onko kyseessä enää yksikkötesti vai onko kyseessä jo suurempaa kokonaisuutta kartoittava integraatiotesti?</p>

<p>Integraatiotestaukseksi luokiteltavia testejä ovat ainakin seuraavanlaiset, selkeästi isompia osakokonaisuuksia testaavat testit</p>
<ul>
  <li>sovelluslogiikan ja tietokannan yhteistoiminnallisuuden varmistaminen</li>
  <li>sovelluksen palvelimen eli backendin tarjoaman HTTP-rajapinnan oikean toiminnallisuuden varmistaminen</li>
</ul>

<p>Yksikkötestauksen tapaan, koodin integroinnin ja usein myös integraatiotestauksen katsotaan nykyään olevan sovelluskehittäjien vastuulla, eli integraatiotestaus kuuluu käsitteen <a href="https://developertesting.rocks/">developer testing</a> alle.</p>

<h2 id="regressiotestaus">Regressiotestaus</h2>

<p>Iteratiivisessa ja ketterässä ohjelmistotuotannossa, jossa jokainen iteraatio tuottaa ohjelmistoon uusia ominaisuuksia, on oltava koko ajan valppaana sen suhteen, että lisäykset eivät hajota ohjelman jo toimivia osia.</p>

<p>Testit on siis suoritettava uudelleen aina kun ohjelmistoon tehdään muutoksia. Tätä käytäntöä kutsutaan <em>regressiotestaukseksi</em>. Jotta varmuus ohjelmiston virheettömänä pysymisestä olisi mahdollisimman suuri, tulee regressiotestien joukon koostua sekä yksikkö-, integraatio- että järjestelmätesteistä.</p>

<p>Usein regressiotesteinä käytetään kaikkia sovelluskehityksen aikana tehtyjä testejä. On myös tilanteita, joissa tämä ei ole mielekästä esimerkiksi testien suorituksen viemän ajan takia, ja sopiva osajoukko kaikista testeistä voi taata riittävän luottamuksen sovelluksen virheettömänä säilymisestä.</p>

<p>Testaaminen on erittäin työlästä ja regressiotestauksen tarve tekee siitä entistä työläämpää. Tämän takia on erittäin tärkeää pyrkiä automatisoimaan testit mahdollisimman suurissa määrin.</p>

<p>Automatisoitu yksikkötestaus on jo aiemmilta kursseilta tuttu aihe. Käsittelemme muutamia järjestelmätestauksen automatisoinnin menetelmiä seuraavissa luvuissa.</p>

<h2 id="ketterien-menetelmien-testauskäytänteitä">Ketterien menetelmien testauskäytänteitä</h2>

<p>Testauksen rooli ketterissä menetelmissä poikkeaa huomattavasti vesiputousmallisesta ohjelmistotuotannosta. Iteraation/sprintin aikana toteutettavat ominaisuudet integroidaan muuhun koodiin ja testataan yksikkö-, integraatio- sekä järjestelmätasolla. Sykli ominaisuuden määrittelystä siihen, että se on valmis ja testattu on erittäin lyhyt, viikosta kuukauteen.</p>

<p>Testausta tehdäänkin sprintin “ensimmäisestä päivästä” lähtien ja testaus integroitu suunnitteluun ja toteutukseen, eikä ole ketterän näkemyksen mukaan enää oma erillinen vaiheensa.</p>

<p>Ketterän kehityksen luonne vaatiikin, että testejä voidaan suorittaa usein ja mahdollisimman vähällä vaivalla, siispä automatisoitu regressiotestaus on avainasemassa.</p>

<p>Kuten Scrumin käsittelyn yhteydessä <a href="/osa1#kehittäjätiimi">mainittiin</a>, ketterien sovelluskehitystiimien tulisi olla <em>cross functional</em>, eli sisältää kaikki tietotaito, mitä järjestelmän kehittäminen ja tuotantokäyttöön valmiiksi saattaminen edellyttää. Tämän takia testaajat on ideaalitilanteessa sijoitettu erillisen laatua valvovan QA-organisaation sijaan kehittäjätiimeihin, ja myös ohjelmoijat kirjoittavat testejä.</p>

<p>Testaajan rooli muuttuu virheiden etsijästä virheiden estäjään: testaaja auttaa tiimiä kirjoittamaan automatisoituja testejä, jotka pyrkivät estämään bugien pääsyn koodiin. Eräänä kantavana teemana ketterässä laadunhallinnassa onkin “sisäänrakentaa laatu tuotteisiin”, eli Lean-maailmasta tuttu periaate <a href="https://www.101ways.com/2010/09/06/lean-principles-2-build-quality-in/">build quality in</a>. Tämä tarkoittaa sitä, että laadunhallintaan ei suhtauduta erillisen organisaation (esim. QA-tiimin) vastuulla olevana asiana, vaan sovelluskehityksessä on jo lähtökohtana se, että bugeja ei pääse syntymään, ja jos pääsee, ne tulee havaita mieluiten jo ohjelmointivaiheessa.</p>

<p>Käymme tässä luvussa läpi joukon ketterien menetelmien suosimia testauskäytäntöjä.</p>

<p><em>Test driven development</em> eli TDD on kehitysmenetelmä, missä testit tehdään jo ennen koodin kirjoittamista. Nimestään huolimatta kyseessä tosin on enemmän suunnittelu- ja toteutustason tekniikka, jonka sivutuotteena syntyy kattava joukko automaattisesti suoritettavia testejä.</p>

<p>User storyjen tasolla tapahtuva automatisoitu testaus, joka kulkee nimillä <em>acceptance test driven development</em> ja <em>behavior driven development</em>.</p>

<p><em>Continuous Integration</em> eli jatkuva integraatio ja <em>(continuous delivery)</em> eli jatkuva toimitusvalmius ovat perinteisen integraatio- ja integraatiotestausvaiheen korvaava työskentelytapa, jossa pyrkimyksenä on integroida ja jopa viedä tuotantoympäristöön jokainen sovellukseen tehty muutos.</p>

<p>Kaikista edellisistä käytänteistä seurauksena on suuri joukko eritasoisia (eli yksikkö-, integraatio-, järjestelmä-) automatisoituja testejä, joiden avulla tehty regressiotestaus mahdollistaa sen, että ohjelmiston jatkokehityksen aikana voidaan olla turvallisin mielin siitä, että jo toimivia asioita ei pääse hajoamaan.</p>

<p>Nousevana trendinä on suorittaa uusien ominaisuuksien laadunhallintaa myös siinä vaiheessa kun osa oikeista käyttäjistä on jo ottanut ne käyttöönsä. Tehdään testaus miten kattavasti tahansa, on kuitenkin hyvin tyypillistä, että tiettyjä ongelmia ilmenee vasta todellisessa käytössä. Tuotantokäytössä tapahtuva testaus on suurta kurinalaisuutta vaativa menetelmä, joka vaatii pitkälle kehittynyttä automatisointia ja ohjelmiston sofistikoitunutta monitorointia.</p>

<p>Voimakkaasta automatisointitrendistä huolimatta myös manuaalisesti tehtävällä testauksella on edelleen paikkansa. Tutkiva testaus (engl. exploratory testing) on pääosin manuaalinen järjestelmätestauksen tekniikka, jossa testaaminen tapahtuu ilman tarkkaa etukäteen tehtävää testaussuunnitelmaa. Testaaja luo lennossa uusia testejä edellisten testien antaman palautteen perusteella. Tutkivaa testausta käytetään usein kokonaan uusien ohjelmiston ominaisuuksien testaamiseen.</p>

<h2 id="test-driven-development">Test driven development</h2>

<p><a href="https://martinfowler.com/bliki/TestDrivenDevelopment.html">Test driven development</a> eli TDD (suomeksi testivetoinen kehitys) on yksi <a href="http://www.extremeprogramming.org/">eXtreme Programmingin</a> käytänteistä, missä siis testit on tarkoitus tehdä ennen varsinaisen koodin kirjoittamista.</p>

<p>Alan auktoriteettien kuten Kent Beckin ja Uncle Bob Martinin <a href="http://butunclebob.com/ArticleS.UncleBob.TheThreeRulesOfTdd">määritelmän mukainen</a> TDD etenee seuraavasti</p>

<ol>
  <li>Kirjoitetaan testiä sen verran että testi ei mene läpi. Ei siis luoda heti kaikkia luokan tai metodin testejä, vaan edetään yksi testi kerrallaan.</li>
  <li>Kirjoitetaan koodia sen verran, että testi saadaan menemään läpi. Ei yritetäkään heti kirjoittaa “lopullista” koodia.</li>
  <li>Jos huomataan koodin rakenteen menneen huonoksi (eli havaitaan koodissa esimerkiksi toisteisuutta tai liian pitkiä metodeja) <em>refaktoroidaan</em> koodin rakenne paremmaksi, ja huolehditaan koko ajan. että testit menevät edelleen läpi. Refaktoroinnilla tarkoitetaan koodin sisäisen rakenteen muuttamista siten, että sen rajapinta ja toiminnallisuus säilyy muuttumattomana.</li>
  <li>Jatketaan askeleesta 1</li>
</ol>

<p>TDD:n etenemisestä käytetään usein nimitystä <em>red-green-refactor</em>, eli tehdään testi joka on punaisella, kirjotetaan koodia siten että testit menevät taas vihreäksi ja jos tarvetta, niin refaktoroidaan. Seuraava kuva havainnollistaa syklin etenemistä:</p>

<p><img src="http://localhost:4000/images/3-6a.png" alt="" height="250px" /></p>

<p>TDD:llä ohjelmoitaessa toteutettavaa komponenttia ei yleensä ole tapana suunnitella tyhjentävästi etukäteen. Testit kirjoitetaan ensisijaisesti ajatellen komponentin käyttöä, eli huomio on komponentin rajapinnassa ja rajapinnan helppokäyttöisyydessä, ei niinkään komponentin sisäisessä toteutuksessa. Komponentin sisäinen rakenne muotoutuu refaktorointien kautta.</p>

<p>TDD:ssä perinteisen suunnittelu-toteutus-testaus -syklin voi ajatella kääntyneen täysin päinvastaiseen järjestykseen, komponentin tarkka suunnittelu tapahtuu vasta refaktorointien yhteydessä.</p>

<h3 id="tddn-hyviä-puolia">TDD:n hyviä puolia</h3>

<p>TDD:tä tehtäessä korostetaan yleensä lopputuloksen yksinkertaisuutta, tarkoituksena on toteuttaa toiminnallisuutta vain sen verran, mitä testien läpimeno edellyttää. Ei siis toteuteta “varalta” ekstratoiminnallisuutta, sillä sitä ei todennäköisesti tarvita. Tästä yksinkertaisiin ratkaisuihin pyrkivästä käytännöstä käytetään usein nimitystä <a href="https://martinfowler.com/bliki/Yagni.html">“You ain’t gonna need it”, YAGNI</a>, sama periaate on kirjattuna ketterään manifestiin muodossa <em>Simplicity – the art of maximizing the amount of work not done – is essential</em>.</p>

<p>Koodista on vaikea tehdä helposti testattavissa olevaa, jos se ei ole modulaarista ja löyhästi kytketyistä selkeän rajapinnan omaavista komponenteista koostuvaa. Määritelmän mukaisella TDD:llä ohjelmoitaessa taas koodista tulee useimmiten jo lähtökohtaisesti modulaarista ja vähäistä turhilta riippuvuuksiltaan. Tälläisen koodin taas on huomattu olevan laadukasta ylläpidettävyyden ja laajennettavuuden kannalta. Eli eräs argumentti TDD:n puolesta on juuri ollut sen tuottama laajennettavuuden ja jatkokehitettävyyden kannalta edullinen koodin laatu.</p>

<p>Muina TDD:n hyvinä puolina mainitaan, että se rohkaisee ottamaan pieniä askelia kerrallaan ja näin toimimaan fokusoidusti, ja että hyvin kirjoitetut testit toimivat toteutetun komponentin rajapinnan dokumentaationa.</p>

<p>TDD:tä on tutkittu akateemisesti kohtuullisen paljon. Kovin suurta evidenssiä sen hyödyistä <a href="https://researchportal.helsinki.fi/fi/publications/effects-of-test-driven-development-a-comparative-analysis-of-empi">ei ole</a> havaittu, tosin tutkimusasetelmat eivät ole olleet kovin vakuuttavia ja realistisia käyttötilanteita vastaavia, niissä ei ole juurikaan otettu kantaa mahdollisiin pitkän aikavälin hyötyihin, joita ylläpidettävyydeltään laadukas koodi mahdollisesti tuottaa.</p>

<h3 id="tddllä-on-myös-ikävät-puolensa">TDD:llä on myös ikävät puolensa</h3>

<p>Käytettäessä TDD:tä testikoodia tulee paljon, usein suunnilleen saman verran kuin varsinaista koodia. Jos ja kun sovellus muuttuu, tulee testejä myös ylläpitää, sillä monet suuremmat rakenteelliset muutokset rikkovat usein osan testeistä.</p>

<p>TDD:n soveltaminen on haastavaa mm. käyttöliittymä-, tietokantayhteyksistä sekä verkon yli kommunikoinnista huolehtivaa koodia tehtäessä, mahdotonta se ei kuitenkaan ole. Jo olemassa olevan koodin laajentaminen TDD:llä voi myöskin olla erittäin haastavaa erityisesti jos laajennettava koodi on rakenteeltaan vanhan liiton spagettikoodia.</p>

<h2 id="riippuvuuksien-hallinta-testeissä">Riippuvuuksien hallinta testeissä</h2>

<p>Testatessa on ratkaistava kysymys, miten testeissä suhtaudutaan testattavien luokkien riippuvuuksiin, eli luokkiin, joiden oliota testattava luokka käyttää.</p>

<p>Laskareista tuttu <a href="/riippuvuuksien_injektointi/">riippuvuuksien injektio</a> -suunnittelumalli parantaa luokkien testattavuutta, sillä se mahdollistaa riippuvuuksien asettamisen luokille testistä käsin.</p>

<p>Yksi mahdollisuus on tehdä testejä varten riippuvuudet korvaavia tynkäkomponentteja, eli <em>stubeja</em>, näin tehtiin mm. <a href="/tehtavat1#16-nhlstatistics-ohjelman-yksikk%C3%B6testaus">viikon 1 tehtävässä 16</a>. Stubeihin voidaan esim. kovakoodata metodikutsujen tulokset valmiiksi. Testit voivat myös kysellä stubilta millä arvoilla testattava metodi sitä kutsui ja näin varmistaa, että testattava koodi on kommunikoinut riippuvuuksiensa kanssa oletetulla tavalla.</p>

<p>Tynkäkomponentteja kutsutaan niiden ominaisuuksista riippuen joko stubeiksi tai mock-olioiksi, Martin Fowlerin <a href="http://martinfowler.com/articles/mocksArentStubs.html">artikkeli</a> selventää asiaa ja terminologiaa. Yleensä stubeksi kutsutaan sellaisia tynkäkomponentteja, jotka ainoastaan palauttavat kovakoodattuja metodikutsujen paluuarvoja. Mock-olioissa taas on enemmän “älyä”, ne osaavat mm. tarkkailla onko niiden määrittelemiä metodeja kutsuttu oikeilla parametreilla ja halutun monta kertaa.</p>

<p>On olemassa useita kirjastoja mock-olioiden luomisen helpottamiseksi, tutustumme laskareissa Javalle tarkoitettuun <a href="https://site.mockito.org/">Mockito</a>-kirjastoon.</p>

<p>Tarkastellaan hieman Mockiton toimintalogiikkaa viikon 2 <a href="/tehtavat2/">laskareiden</a> verkkokauppatehtävää esimerkkinä käyttäen.</p>

<p>Ostotapahtuman yhteydessä verkkokaupan tulisi veloittaa asiakkaan tililtä ostosten hinta <em>kutsumalla luokan pankki metodia tilisiirto</em>.</p>

<p><img src="http://localhost:4000/images/3-7.png" alt="" height="220px" /></p>

<p>Tästä koodista pitäisi siis testata, että metodikutsu <em>kauppa.maksa(“1111”)</em> tekee ostosten summaa vastaavan tilisiirron pankkitililtä <em>“1111”</em> kaupan tilille.</p>

<p>Miten varmistamme, että tilisiirron suorittavaa luokan <em>Pankki</em> olion metodia on kutsuttu oikeilla parametreilla?</p>

<p>Mockito-kirjastoa käyttäen tämä onnistuu seuraavasti. Luodaan testissä kaupan riippuvuuksista mock-oliot:</p>

<p><img src="http://localhost:4000/images/3-8.png" alt="" height="350px" /></p>

<p>Pankkia edustavalle mock-oliolle on asetettu <em>ekspektaatio</em>, eli vaatimus, joka varmistaa että metodia <em>tilisiirto</em> on kutsuttu testin aikana sopivilla parametreilla. Jos tämä vaatimus ei täyty, testi ei mene läpi.</p>

<p>Pääset harjoittelemaan Mockiton käyttöä viikon 3 <a href="/tehtavat3/">laskareissa</a>.</p>

<h2 id="user-storyjen-testaaminen">User storyjen testaaminen</h2>

<p>User storyn <a href="/osa2#user-story">määritelmän</a> yhteydessä mainittiin, että user storyn käsite pitää sisällään <em>hyväksymiskriteerit</em>, Mike Cohnin sanoin:</p>

<p><em>tests that convey and document details and that will be used to determine that the story is complete</em></p>

<p>Esimerkiksi user storyn <em>asiakas voi lisätä tuotteen ostoskoriin</em> hyväksymiskriteeriejä voisivat olla</p>
<ul>
  <li>ollessaan tuotelistauksessa ja valitessaan tuotteen jota on varastossa, menee tuote ostoskoriin ja ostoskorin hinta sekä korissa olevien tuotteiden määrä päivittyy oikein</li>
  <li>ollessaan tuotelistauksessa ja valitessaan tuotteen jota ei ole varastossa, pysyy ostoskorin tilanne muuttumattomana</li>
</ul>

<p>Optimaalisessa tilanteessa user storyjen hyväksymiskriteereistä saadaan muodostettua suurin osa ohjelmiston järjestelmätason, eli käyttäjän näkökulmasta sovelluksen toiminnallisuuden varmistavista toiminnallisista testeistä.</p>

<p>Storyn hyväksymiskriteerit on tarkoituksenmukaista kirjoittaa heti storyn toteuttavan sprintin alussa, mielellään yhteistyössä kehitystiimin ja product ownerin tai jonkun muun asiakkaan edustajan kesken. Usein käytäntönä on ilmaista hyväksymiskriteerit user storyjen tapaan asiakkaan kielellä, käyttämättä teknistä jargonia. Hyväksymiskriteerien kirjoitusprosessi lisääkin parhaassa tapauksessa asiakkaan ja tiimin välistä kommunikaatiota.</p>

<h3 id="järjestelmätestauksen-automatisointi-atdd-ja-bdd">Järjestelmätestauksen automatisointi, ATDD ja BDD</h3>

<p>Ideaalitilanteessa storyjen hyväksymiskriteereistä tehdään automaattisesti suoritettavia.</p>

<p>Automaattisen hyväksymistestauksen on olemassa monia työkaluja, eräs suosituimmista on suomalainen python-pohjainen <a href="https://robotframework.org/">Robot framework</a>. Käytämme kurssilla kuitenkin useita eri kieliä tukevaa <a href="https://cucumber.io/">Cucumberia</a>.</p>

<p>Automatisoidusta hyväksymistestauksesta käytetään joskus nimitystä <a href="https://en.wikipedia.org/wiki/Acceptance_test%E2%80%93driven_developmen">Acceptance test driven development</a> (ATDD) tai <em><a href="https://en.wikipedia.org/wiki/Behavior-driven_development">Behavior driven development</a></em> (BDD), erityisesti jos testit toteutetaan jo iteraation alkupuolella, ennen kun storyn toteuttava koodi on valmiina.</p>

<p>ATDD:ssä ja BDD:ssä on kyse lähes samasta asiasta pienin painotuseroin. BDD kiinnittää tarkemmin huomiota käytettävään terminologiaan, BDD ei esimerkiksi puhu ollenkaan testeistä vaan sensijaan kuvailee hyväksymiskriteerit esimerkkikäyttäytymisten (example behavior) avulla. Kurssilla käytämme pääosin BDD:n nimeämiskäytäntöjä, sillä käyttämämme <a href="https://cucumber.io/">Cucumber</a> on nimenomaan BDD-piirien kehittämä työkalu.</p>

<p>Käsite ATDD pitää sisällään aina ainoastaan hyväksymistason testauksen. BDD:llä voidaan tehdä myös muita, kuin hyväksymistason testejä. Rubylle alun perin kehitetty <a href="https://rspec.info/">rspec</a> sanoo olevansa BDD-kirjasto, rspec sopii hyväksymistestien lisäksi hyvin myös yksikkötestaamiseen. Muille kielille on tehty paljon rspecin tapaan toimivia BDD-henkisiä kirjastoja, kuten Javascript-maailman <a href="https://mochajs.org/">mocha</a> ja <a href="https://jestjs.io/">jest</a>. Seuraavaksi käsiteltävä Cucumber on kuitenkin nimenomaan hyväksymistestaukseen työväline, yksikkötestaamiseen sitä ei kannata käyttää.</p>

<h3 id="cucumber">Cucumber</h3>

<p>Kuten useimmissa hyväksymistason testauksen työkaluissa, myös Cucumberia käytettäessä testit kirjoitetaan asiakkaan kielellä.</p>

<p>Tarkastellaan esimerkkinä käyttäjätunnuksen luomisen ja sisäänkirjautumisen tarjoamaa palvelua.</p>

<p>Palvelun vaatimuksen määrittelevät user storyt</p>
<ul>
  <li><em>a new user account can be created if a proper unused username and a proper password are given</em></li>
  <li><em>user can log in with a valid username/password-combination</em></li>
</ul>

<p>Cucumberissa jokaisesta user storysta kirjoitetaan oma <em>.feature</em>-päätteinen tiedosto, joka sisältää storyn nimen ja joukon storyyn liittyvä hyväksymiskriteereitä ,joita Cucumber kutsuu <em>skenaarioiksi</em>. Storyn hyväksymiskriteerit eli skenaariot kirjoitetaan <a href="https://cucumber.io/docs/gherkin/reference/">Gherkin</a>-kielellä, seuraavassa muodossa</p>

<p><em>Given [initial context], when [event occurs], then [ensure some outcomes]</em></p>

<p>Esimerkkimme ensimmäinen user story hyväksymiskriteereineen kirjoitettaisiin seuraavasti:</p>

<p><img src="http://localhost:4000/images/3-9.png" alt="" height="450px" /></p>

<p>Skenaariot muutetaan automaattisesti suoritettaviksi testeiksi kirjoittamalla niistä mäppäys ohjelmakoodiin. Ohjelmoijat tekevät mäppäyksen siinä vaiheessa, kun tuotantokoodia on tarpeellinen määrä valmiina.</p>

<p>Käytännössä jokaista testin <em>given</em>, <em>when</em> ja <em>then</em>-askelta vastaa oma metodinsa.
Metodit kutsuvat ohjelman luokkia simuloiden käyttäjän syötettä varmistaen, että ohjelma reagoi käyttäjän toimiin halutulla tavalla.</p>

<p><img src="http://localhost:4000/images/3-10a.png" alt="" height="500px" /></p>

<h3 id="websovellusten-testauksen-automatisointi">Websovellusten testauksen automatisointi</h3>

<p>Olemme jo nähneet ensimmäisen ja toisen viikon laskareissa, miten riippuvuuksien injektoinnin avulla on helppo tehdä komentoriviltä toimivista ohjelmista automatisoidusti testattavia. Myös Java Swing, JavaFX ja muilla käyttöliittymäkirjastoilla sekä web-selaimella käytettävien sovellusten automatisoitu testaaminen on mahdollista. Tutustumme laskareissa web-sovellusten testauksen automatisointiin käytettävään <a href="http://seleniumhq.org/docs/03_webdriver.html">Selenium 2.0 WebDriver</a> -kirjastoon.</p>

<p>Selenium tarjoaa rajapinnan, jonka avulla on mahdollisuus simuloida ohjelmakoodista tai testeistä käsin selaimen toimintaa, esim. linkkien klikkaamista ja tiedon syöttämistä lomakkeeseen. Selenium Webdriver -rajapinta on käytettävissä lähes kaikilla ohjelmointikielillä.</p>

<p>Seleniumia käyttävät testit voi tehdä normaalin testikoodin tapaan joko JUnit- tai Cucumber-testeinä.</p>

<p>Seuraavassa esimerkki käyttäjätunnuksista ja sisäänkirjautumisesta huolehtivan järjestelmän web-version testien mäppäyksestä:</p>

<p><img src="http://localhost:4000/images/3-11a.png" alt="" height="500px" /></p>

<p>Cucumberiin ja web-sovellusten testaamiseen tutustutaan tarkemmin viikon 3 laskareissa.</p>

<h2 id="ohjelmiston-integraatio">Ohjelmiston integraatio</h2>

<p>Vesiputousmallissa eli lineaarisesti etenevässä ohjelmistotuotannossa ohjelmiston toteutusvaiheen päättää integraatiovaihe, jonka aikana yksittäin testatut komponentit integroidaan yhdessä toimivaksi kokonaisuudeksi sekä suoritetaan integraatiotestaus, joka varmistaa komponenttien yhteistoiminnallisuuden.</p>

<p>Perinteisesti juuri integraatiovaihe on tuonut esiin suuren joukon ongelmia. Tarkasta etukäteissuunnittelusta huolimatta erillisten tiimien toteuttamat komponentit ovat kuitenkin olleet rajapinnoiltaan tai toiminnallisuuksiltaan epäyhteensopivia.</p>

<p>Suurten projektien integraatiovaihe on kestänyt ennakoimattoman kauan, ja integraation aikana havaitut ongelmat ovat saattaneet aiheuttaa suuriakin suunnitteluun tai jopa vaatimusmäärittelyyn tarvittavia muutoksia.</p>

<p>Integraatio on ollut perinteisesti niin ikävä ja hankala vaihe, että sitä kuvaamaan on lanseerattu termi <a href="http://wiki.c2.com/?IntegrationHell">integraatiohelvetti</a>.</p>

<h3 id="daily-build-ja-smoke-test">Daily build ja smoke test</h3>

<p>90-luvulla alettiin huomaamaan, että riskien minimoimiseksi integraatio kannattaa tehdä useammin kuin vain projektin lopussa. Parhaaksi käytänteeksi alkoi muodostumaan päivittäin tehtävä koko projektin kääntäminen eli <em>daily build</em> ja samassa yhteydessä suoritettava <em>smoke test</em>. Nämä käytänteet alkoivat nousta suurempaan tietoisuuteen 90-luvun puolessa välissä erityisesti <a href="https://stevemcconnell.com/articles/daily-build-and-smoke-test/">Microsoftin</a> Excel ja Windows 95 -tiimien menestysten ansiosta.</p>

<p>Smoke testillä tarkoitetaan kohtuullisen yksinkertaista järjestelmätason testiä, joka kuitenkin testaa järjestelmän kaikkia arkkitehtuurillisia tasoja (käyttöliittymää, sovelluslogiikkaa, tietokantaa), ja havaitsee jos jotain on pahasti pielessä. Smoke test ei siis kata kovin paljoa sovelluksen toiminnallisuudesta, mutta kuitenkin riittävästi havaitakseen jos sovellus hajoaa perustavanlaatuisella tavalla, esimerkiksi jos sovelluslogiikan ja tietokannan välille syntyy epäyhteensopivuus, joka estää kokonaan tietokantayhteyksien muodostamisen.</p>

<p>Daily buildia ja smoke testiä käytettäessä järjestelmän integraatio tehdään ainakin jollain tarkkuustasolla joka päivä. Komponenttien yhteensopivuusongelmat huomataan nopeasti ja niiden korjaaminen helpottuu. Tiimin moraali myös paranee, kun ohjelmistosta on olemassa päivittäin kasvava ainakin jossain määrin toimiva versio.</p>

<h3 id="jatkuva-integraatio">Jatkuva integraatio</h3>

<p>Kerran päivässä tapahtuva integraatiovaihe todettiin hyväksi käytännöksi. Extreme programming -yhteisö kehitti 90-luvun loppupuolella ideaa vielä pidemmälle ja päätyi edelleen tihentämään integraatiosykliä. Näin syntyi <em>jatkuva integraatio</em> eli <a href="https://martinfowler.com/articles/continuousIntegration.html">continuous integration</a> (CI).</p>

<p>Jatkuvaa integraatiota käytettäessä ohjelmakoodi, ohjelman käyttämien kirjastojen konfiguraatiot, automatisoidut testit sekä ohjelmiston kääntämisestä ja testaamisesta huolehtivat “build skriptit” (kuten <em>build.gradle</em>-tiedosto) pidetään keskitetyssä versionhallintarepositoriossa.</p>

<p>Yksittäinen palvelin, jonka konfiguraatio vastaa mahdollisimman läheisesti tuotantopalvelimen konfiguraatiota, varataan CI-palvelimeksi. Kun keskitetyssä repositoriossa olevaan koodiin tulee muutoksia,  CI-palvelin hakee ohjelmiston koodin, kääntää sen sekä suorittaa sille testit. Jos koodi ei käänny tai testit eivät mene läpi, CI-palvelin kertoo ongelmista kehittäjätiimille, ja ongelmiin on tarkoitus puuttua <strong>välittömästi</strong>.</p>

<p>Sovelluskehittäjän työskentely jatkuvaa integraatiota käytettäessä etenee seuraavasti.</p>

<p>Aloittaessaan uuden ominaisuuden toteuttamisen, kehittäjä hakee versionhallinnasta koodin ajantasaisen version. Kehittäjä toteuttaa työn alla olevan ominaisuuden, tekee sille automatisoidut testit ja integroi sen muuhun koodiin. Kun kaikki on valmiina, ja testit menevät läpi paikallisesti, pushaa kehittäjä koodin versionhallintaan.</p>

<p>CI-palvelin huomaa tehdyt muutokset, hakee koodit ja suorittaa testit. Näin minimoituu mahdollisuus sille, että lisätty koodi toimii esimerkiksi konfiguraatioerojen takia ainoastaan kehittäjän omalla koneella.</p>

<p>Jatkuvan integraation tarkoituksena on siis se, että <em>jokainen kehittäjä integroi tekemänsä työn muuhun koodiin mahdollisimman usein, vähintään kerran päivässä</em>. CI siis rohkaisee jakamaan työn pieniin osiin, sellaisiin jotka saadaan testeineen “valmiiksi” yhden työpäivän aikana. Jatkuvan integraation soveltaminen vaatiikin suurta kurinalaisuutta.</p>

<p>Täydellisenä kontrastina vesiputousmaailman integraatiohelvettiin, jatkuvan integraation pyrkimyksenä on tehdä ohjelmiston integraatiosta täysin vaivaton operaatio, joka takaa sen että ohjelmistosta on koko ajan saatavilla ajantasainen, kokonaisuudessaan integroitu ja testattu versio.</p>

<p>Jotta CI-prosessi toimisi riittävän jouhevasti, tulee testien suorittamisen tapahtua suhteellisen nopeasti, maagisena rajana pidetään usein kymmentä minuuttia. Erityisesti käyttöliittymän läpi suoritettavat hyväksymistestit voivat kuitenkin olla yllättävän aikaa vieviä. Jos testien suoritusaika alkaa kasvaa liikaa, voidaan testit konfiguroida ajettavaksi <em>kahdessa vaiheessa</em>. Testien ensimmäisen vaiheen <em>commit buildin</em> läpimeno antaa kehittäjälle riittävän varmuuden pushata uusi koodi versionhallintaan. CI-palvelimella suoritetaan sitten myös hitaammat testit sisältävä <em>secondary build</em>.</p>

<p>Monimutkaisemmissa tilanteissa testaus voidaan jakaa vieläkin useampaan vaiheeseen. Sovellukselle saatetaan tehdä esim. kuormituksen kestoa mittaavia testejä, joiden suorituksessa kestää useita tunteja. Tällaisia testejä ei ole missään nimessä tarkoituksenmukaista suorittaa jokaisen versionhallintaan tapahtuvan koodin muutoksen (eli commitin) yhteydessä, vaan esimerkiksi kerran vuorokaudessa.</p>

<p>Ensimmäisen viikon laskareissa käytetty <a href="https://circleci.com">CircleCI</a> on yksi monista SaaS-palveluna eli internetissä toimivista CI-ratkaisuista, toinen suosittu vaihtoehto on <a href="https://travis-ci.org/">Travis</a>. Eräs SaaS-palveluina toimivien CI-ratkaisujen suurista eduista on se, että tarvetta oman CI-palvelimen asentamiselle ja ylläpitämiselle ei ole.</p>

<p>Circlea ja Travisia paljon vanhempi <a href="https://jenkins.io/">Jenkins</a> lienee edelleen maailmalla eniten käytetty CI-palvelinohjelmisto. Tällä hetkellä ei kuitenkaan ole yhtään ilmaista internetissä palveluna toimivaa Jenkins-palvelua. Jenkinsin käyttö siis edellyttää sen asentamista omalle palvelimelle. Vaikka Jenkins on suosittu ja sillä voi tehdä melkein mitä tahansa on se kuitenkin aika vanhan liiton ohjelmisto verrattuna uudempiin tulokkaisiin, kuten Circleen.</p>

<p>GitHub kertoi loppukesästä julkaisevansa 15.11.2019 <a href="https://www.youtube.com/watch?v=E1OunoCyuhY">actions</a>-toiminnallisuuden, jonka avulla myös jatkuva integraatio voidaan suorittaa suoraan GitHubissa, käyttämättä erillistä palvelua. Tämä on erittäin kiinnostava uutinen, harmi että julkistus tapahtuu tämän kurssin kannalta hieman liian myöhään. Ennakkotiedot ovat kuitenkin olleet sen suuntaisia, että ainakaan ihan lähiaikoina GitHubin actionit eivät ole toiminnallisuudeltaan riittävän joustavia moneen tosielämän jatkuvan integraation tarpeeseen.</p>

<h3 id="jatkuvan-integraation-määritelmä">Jatkuvan integraation määritelmä</h3>

<p>Palataan vielä siihen mitä jatkuva integraatio menetelmän <a href="https://martinfowler.com/articles/continuousIntegration.html">pioneerien</a> mukaan oikeastaan tarkoittaa. Jatkuvan integraation tekemiseen <em>ei riitä</em> että joku on konfiguroinut tiimille CI-palvelimen. Jotta tiimin voidaan sanoa tekevän jatkuvaa integraatiota, tulee sovelluskehittäjien todellakin synkronoida tekemänsä koodi mahdollisimman usein (vähintään päivittäin) yhteisen keskitetyn repositorion koodin kanssa. Tämä taas tarkoittaa sitä, että esimerkiksi jokaisen aamun alussa kaikilla sovelluskehittäjillä tulisi olla päivän työnsä lähtökohtana <em>sama koodi</em>. Kuten jokainen tiimissä sovelluskehitystä tehnyt tietää, kaikkien koodin synkronointi päivittäisellä tasolla ei välttämättä ole helppoa ja se vaatii systemaattista ja kurinalaista työskentelyä.</p>

<p>Nykyään monin paikoin käytössä oleva tapa käyttää useiden päivien tai jopa viikkojen ikäisiä <a href="https://martinfowler.com/bliki/FeatureBranch.html">feature branchejä</a>, eli jokaiselle uudelle toiminnallisuudelle tarkoitettuja omia versionhallinnan haaroja tarkoittaa oikeastaan jo lähtökohtaisesti sitä, että tiimi <a href="https://www.innoq.com/en/blog/continuous-integration-contradicts-feature-branches/">ei harjoita jatkuvaa integraatiota</a>. Palaamme asiaan <a href="/osa3/-feature-branchit-ja-merge-hell">myöhemmin</a> tässä osassa.</p>

<h2 id="jatkuva-käyttöönotto-ja-toimitusvalmius">Jatkuva käyttöönotto ja toimitusvalmius</h2>

<p>Viime aikoina nousseen trendin mukaan jatkuvaa integraatiota on ruvettu viemään vielä muutama askel pidemmälle ja integraatioprosessiin on enenevissä määrin ruvettu lisäämään myös automaattinen “deployaus”, eli käännetty ja testattu koodi siirretään automatisoidusti suoritettavaksi ns. <em>staging</em>- eli testipalvelimelle.</p>

<p>Staging-palvelin on ympäristö, joka on konfiguraatioidensa sekä myös sovelluksessa käsiteltävän datan (käytännössä siis tietokannan sisällön) osalta mahdollisimman lähellä varsinaista tuotantoympäristöä. Kun ohjelmiston uusi versio on viety eli deployattu staging-palvelimelle, suoritetaan sille hyväksymistestaus. Nämä testit ovat lähinnä järjestelmätason testejä, jotka varmistavat, että sovellus toimii käyttäjän haluamalla tavalla mahdollisimman tuotannon kaltaisessa ympäristössä.</p>

<p>Hyväksymistestauksen jälkeen uusi versio voidaan siirtää tuotantopalvelimelle, eli loppukäyttäjien käyttöön. Parhaassa tapauksessa myös staging-ympäristössä tehtävien hyväksymistestien suoritus on automatisoitu, ja ohjelmisto kulkee koko <em>deployment pipelinen</em> läpi, eli sovelluskehittäjän koneelta CI-palvelimelle, sieltä staging-ympäristöön ja lopulta tuotantoon, automaattisesti.</p>

<p>Termillä <em>deployment pipeline</em> tarkoitetaan niitä ohjelman käännöksen ja testauksen vaiheita, joiden läpikäymistä edellytetään, että ohjelma saadaan siirrettyä tuotantoympäristöön loppukäyttäjien käyttöön.</p>

<p>Jokainen sovelluskehittäjän commit kulkee deployment pipelinen eli käsitteellisen “liukuhihnan” läpi</p>
<ul>
  <li>CI-palvelin suorittaa commitille joukon testejä</li>
  <li>seuraavassa vaiheessa commitin aikaansaama sovelluksen uusi versio siirtyy staging-ympäristöön</li>
  <li>staging-ympäristössä sovelluksen uudelle versiolle suoritetaan lisää testejä</li>
  <li>lopulta commit siirtyy tuotantoympäristöön</li>
</ul>

<p><img src="http://localhost:4000/images/3-12.png" alt="" height="280px" /></p>

<p>Käytännöstä, jossa jokainen CI:n läpäisevä ohjelmiston commit, eli versionhallintaan pushattu versio viedään automatisoidusti staging-palvelimelle ja siellä tapahtuvan automatisoidun hyväksymistestauksen jälkeen tuotantoon, nimitetään <em>jatkuvaksi käyttöönotoksi</em> (engl. continuous deployment).</p>

<p>On olemassa tilanteita, missä jokaista commitia ei haluta viedä automaattisesti tuotantoon. Jos viimeinen vaihe, eli tuotantoon vieminen tapahtuukin ainoastaan ihmisen toimesta “nappia painamalla”, puhutaan <em>jatkuvasta toimitusvalmiudesta</em>, (engl. continuous delivery).</p>

<p>Viime aikoina on erityisesti suuren kokoluokan web-palveluissa (esim. Google, Amazon, Netflix, Facebook) ruvettu suosimaan tyyliä, jossa ohjelmistosta julkaistaan uusi versio tuotantoon jopa <a href="https://dzone.com/articles/release-frequency-a-need-for-speed">kymmeniä tai satoja</a> kertoja päivästä.</p>

<h2 id="tutkiva-testaaminen">Tutkiva testaaminen</h2>

<p>Jotta järjestelmä saadaan niin virheettömäksi, että se voidaan laittaa tuotantoon, on testaus suoritettava erittäin perusteellisesti. Perinteinen tapa järjestelmätestauksen suorittamiseen on perustunut ennen testausta laadittuun perinpohjaiseen testaussuunnitelmaan. Jokaisesta testistä on kirjattu testisyötteet ja odotettu tulos. Testauksen tuloksen kontrolloiminen on suoritettu vertaamalla järjestelmän toimintaa testitapaukseen kirjattuun odotettuun tulokseen.</p>

<p>Automatisoitujen hyväksymistestien luonne on täsmälleen samanlainen, jokaisen testin syötteet sekä odotetut tulokset ovat tarkkaan etukäteen kiinnitettyjä. Jos testaus tapahtuu pelkästään etukäteen mietittyjen testien avulla, ovat ne kuinka tahansa tarkkaan harkittuja, ei kaikkia yllättäviä tilanteita osata ennakoida. Hyvät testaajat ovat kautta aikojen tehneet “virallisen” dokumentoidun testauksen lisäksi epävirallista “ad hoc”-testausta. Viime vuosina “ad hoc”-testaus on saanut virallisen aseman ja sen strukturoitua muotoa on ruvettu kutsumaan nimellä <em>tutkiva testaaminen</em> (engl. exploratory testing).</p>

<p>Käsitteen kehittäjä <a href="http://www.satisfice.com/articles/what_is_et.shtml">Cam Kaner</a> määrittelee termin seuraavasti</p>

<p><em>exploratory testing is simultaneous learning, test design and test execution</em></p>

<p>Ideana on, että testaaja ohjaa toimintaansa suorittamiensa testien ohjelmassa aiheuttaman reaktion perusteella. Testitapauksia ei suunnitella kattavasti etukäteen, sensijaan testaaja pyrkii kokemuksensa ja suorittamiensa testien ja kokeilujen perusteella löytämään järjestelmästä virheitä.</p>

<p>Tutkiva testaus ei kuitenkaan etene täysin sattumanvaraisesti, kullekin testisessiolle asetetaan jonkinlainen tavoite, eli mitä osaa tai toiminnallisuuksia sovelluksesta on tarkoitus tutkia ja minkälaisia virheitä tarkoitus etsiä.</p>

<p>Ketterässä ohjelmistotuotannossa tavoite voi hyvin jäsentyä yhden tai useamman user storyn määrittelemän toiminnallisuuden ympärille. Esimerkiksi verkkokaupassa voitaisiin testata ostosten lisäystä ja poistoa ostoskorista.</p>

<p>Tutkivassa testauksessa keskeistä on kaikkien testattavassa ohjelmistossa tapahtuvien seikkojen havainnointi. Normaaleissa etukäteen määritellyissä testeissähän havainnoidaan ainoastaan reagoiko järjestelmä odotetulla, ennakkoon määritellyllä tavalla. Tutkivassa testaamisessa kiinnitetään huomio myös varsinaisen testattavan toiminnallisuuden ulkopuolisiin asioihin.</p>

<p>Esimerkiksi jos huomattaisiin selaimen osoiterivillä URL
https://www.verkkokauppa.com/ostoskori?id=10 voitaisiin yrittää muuttaa käsin ostoskorin id:tä ja yrittää saada järjestelmä epästabiiliin tilaan.</p>

<p>Tutkivan testaamisen avulla löydettyjen virheiden toistuminen jatkossa kannattaa eliminoida lisäämällä ohjelmalle sopivat automaattiset regressiotestit. Tutkivaa testaamista ei siis kannata käyttää regressiotestauksen menetelmänä, vaan sen avulla kannattaa ensisijaisesti testata sprintin yhteydessä toteutettuja uusia ominaisuuksia.</p>

<p>Tutkiva testaaminen siis ei missään tapauksessa ole vaihtoehto normaaleille tarkkaan etukäteen määritellyille ja automatisoiduille testeille, vaan niitä täydentävä testauksen muoto.</p>

<h2 id="tuotannossa-tapahtuva-testaaminen-ja-laadunhallinta">Tuotannossa tapahtuva testaaminen ja laadunhallinta</h2>

<p>Perinteisesti on ajateltu, että ohjelmiston laadunhallintaan liittyvä testaus tulee suorittaa ennen kuin ohjelmisto tai sen uudet toiminnallisuudet on otettu käyttöön eli viety tuotantoympäristöön. Viime aikoina erityisesti web-sovellusten kehityksessä on noussut esiin suuntaus, missä osa laadunhallinnasta tapahtuu monitoroimalla tuotannossa olevaa ohjelmistoa.</p>

<p><img src="http://localhost:4000/images/3-13.png" alt="" height="330px" /></p>

<h3 id="blue-green-deployment">Blue-green-deployment</h3>

<p>Eräs tuotannossa tapahtuvan testaamisen tekniikka on <a href="https://martinfowler.com/bliki/BlueGreenDeployment.html">blue-green-deployment</a>, missä periaatteena on ylläpitää rinnakkain kahta tuotantoympäristöä (tai palvelinta), joista käytetään nimiä blue ja green.</p>

<p>Tuotantoympäristöistä vain toinen on ohjelmiston käyttäjien aktiivisessa käytössä. Käyttäjien ja tuotantopalvelinten välissä oleva komponentti, esimerkiksi ns. reverse proxyna toimiva web-palvelin (kuvassa router) ohjaa käyttäjien liikenteen aktiivisena olevaan ympäristöön.</p>

<p>Kun järjestelmään toteutetaan uusi ominaisuus, deployataan se ensin passiivisena olevaan ympäristöön.</p>

<p><img src="http://localhost:4000/images/3-14.png" alt="" height="220px" /></p>

<p>Passiiviselle, uuden ominaisuuden sisältämälle ympäristölle voidaan sitten tehdä erilaisia testejä, esim. osa käyttäjien liikenteestä voidaan ohjata aktiivisen lisäksi passiiviseen ympäristöön ja varmistaa, että se toimii odotetulla tavalla.</p>

<p>Kun uuden ominaisuuden sisältävän passiivinen ympäristön todetaan toimivan ongelmattomasti, voidaan palvelinten rooli vaihtaa ja uuden ominaisuuden sisältämästä palvelimesta tulee uusi aktiivinen tuotantoympäristö. Aktiivisen tuotantoympäristön vaihto tapahtuu määrittelemällä reverse proxyna web-palvelin ohjaamaan liikenne uudelle palvelimelle.</p>

<p>Jos uuden ominaisuuden sisältävässä versiossa havaitaan aktivoinnin jälkeen jotain ongelmia, on mahdollista suorittaa erittäin nopeasti <em>rollback-operaatio</em>, eli vaihtaa vanha versio jälleen aktiiviseksi.</p>

<p>On tarkoituksenmukaista, että kaikki blue-green-deploymentiin liittyvät testit, niiden tulosten varmistaminen, tuotantoympäristön vaihto ja mahdollinen rollback tapahtuvat automatisoidusti.</p>

<h3 id="canary-release">Canary release</h3>

<p>Blue-green-deploymentin hieman pidemmälle viedyssä versiossa <a href="https://martinfowler.com/bliki/CanaryRelease.html">canary-releasessa</a> uuden ominaisuuden sisältävään ympäristöön ohjataan osa, esim. 5% järjestelmän käyttäjistä:</p>

<p><img src="http://localhost:4000/images/3-15.png" alt="" height="220px" /></p>

<p>Uuden ominaisuuden sisältämää versiota monitoroidaan aktiivisesti ja jos ongelmia ei ilmene, vähitellen kaikki liikenne ohjataan uuteen versioon. Kuten blue-green-deploymentin tapauksessa, ongelmatilanteissa palautetaan käyttäjät aiempaan, toimivaksi todettuun versioon.</p>

<p>Uuden version toimivaksi varmistaminen siis perustuu <em>järjestelmän monitorointiin</em>. Jos kyseessä olisi esim. sosiaalisen median palvelu, monitoroinnissa voitaisiin tarkastella esim.:</p>

<ul>
  <li>palvelun muistin ja prosessoriajan kulutusta sekä verkkoliikenteen määrää</li>
  <li>sovelluksen eri sivujen vasteaikoja eli latautumiseen menevää aikaa</li>
  <li>kirjautuneiden käyttäjien määrää</li>
  <li>luettujen ja lähetettyjen viestien määriä per käyttäjä</li>
  <li>kirjautuneen käyttäjän sovelluksessa viettämää aikaa</li>
</ul>

<p>Monitoroinnissa tulee siis palvelimen yleisen toimivuuden lisäksi seurata
<em>käyttäjätason metriikoita</em> (engl. business level metrics). Jos niissä huomataan eroavuuksia aiempaan, esim. kirjautuneet käyttäjät eivät lähetä keskimäärin samaa määrää viestejä kuin aiemmin, voidaan olettaa, että sovelluksen uudessa versiossa saattaa olla joku ongelma. Tälläisessä tilanteessa saatetaan tehdä rollback vanhaan versioon ja analysoida vikaa tarkemmin.</p>

<p>Myös canary releasejen yhteydessä testauksen ja kaiken tuotantoon vientiin liittyvän on syytä tapahtua automatisoidusti.</p>

<p>Nimi canary release periytyy kaivostyöläisten tavasta käyttää kanarialintuja tutkimaan sitä onko kaivoksessa myrkyllisiä kaasuja: jos kaivokseen viety lintu ei kuole, ilma on turvallista.</p>

<h3 id="tuotannossa-testaaminen-ja-tietokanta">Tuotannossa testaaminen ja tietokanta</h3>

<p>Edellisissä kuvissa oli merkitty järjestelmän vanhalle ja uudelle versiolle erillinen tietokantapalvelin (database server).</p>

<p>Tilanne ei välttämättä ole tämä ja erityisesti canary releasejen yhteydessä järjestelmän molemmat versiot käyttävät yleensä samaa tietokantaa:</p>

<p><img src="http://localhost:4000/images/3-16.png" alt="" height="200px" /></p>

<p>Tämä taas asettaa haasteita, jos järjestelmään toteutetut uudet ominaisuudet edellyttävät muutoksia tietokannan skeemaan, sillä canary releasejen yhteydessä tarvitaan usein yhtä aikaa sekä tietokannan uutta että vanhaa versiota.</p>

<p>Jos järjestelmän uusi ja vanha versio joutuvat jostain syystä käyttämään eri tietokantaa, täytyy kantojen tila synkronoida, jotta järjestelmien vaihtaminen onnistuu saumattomasti. Yhteen kantaan sovelluksen tekemät päivitykset on siis tavalla tai toisella tehtävä myös toiseen, kenties skeemaltaan jo muuttuneeseen kantaan.</p>

<h3 id="feature-toggle">Feature toggle</h3>

<p>Canary releasea havainnollistavassa kuvassa järjestelmän uusi ja vanha versio näytettiin erillisinä palvelimina. Sama voidaan toteuttaa myös käyttäen yksittäistä palvelinta ns. <a href="https://martinfowler.com/articles/feature-toggles.html">feature toggleja</a> hyödyntämällä. Sama asia kulkee myös nimillä feature flag, conditional feature ja config flag. Nimi feature toggle alkaa kuitenkin vakiintua.</p>

<p>Feature togglejen periaate on erittäin yksinkertainen. Koodiin laitetaan ehtolauseita, joiden avulla osa liikenteestä ohjataan vanhan toteutuksen sijaan uuteen laadunhallinnan alla olevaan toteutukseen.</p>

<p>Esimerkiksi sosiaalisen median palvelussa voitaisiin käyttäjälle näytettävien uutisten listaan asettaa feature toggle, jonka avulla tietyin perustein valituille käyttäjille näytettäisiinkin uuden algoritmin perusteella generoitu lista uutisia:</p>

<p><img src="http://localhost:4000/images/3-17.png" alt="" height="180px" /></p>

<p>Canary releaset eivät ole feature togglejen ainoa sovellus, niitä käytetään
yleisesti myös eliminoimaan tarve pitkäikäisille feature brancheille. Eli sen sijaan, että uusia ominaisuuksia toteutetaan erilliseen versionhallinnan haaraan, joka ominaisuuksien valmistumisen yhteydessä mergetään pääkehityshaaraan, uudet ominaisuudet tehdään suoraan pääkehityshaaraan, mutta ne piilotetaan käyttäjiltä feature toggleilla.</p>

<p>Käytännössä feature toggle siis palauttaa aina vanhan version normaaleille käyttäjille. Sovelluskehittäjien ja testaajien taas on mahdollista valita, kumman version feature toggle palauttaa. Kun ominaisuus on valmis testattavaksi laajemmalla joukolla, on ominaisuus mahdollista julkaista feature togglen avulla esim. kehittäjäyrityksen omaan käyttöön ja lopulta osalle käyttäjistä canary releasena. Lopulta feature toggle ja vanha toteutus voidaan poistaa koodista.</p>

<p>Suuret internetpalvelut kuten Facebook, Netflix, Google ja Flickr soveltavat laajalti canary releaseihin ja feature toggleihin perustuvaa kehitysmallia.</p>

<h3 id="feature-branchit-ja-merge-hell">Feature branchit ja merge hell</h3>

<p>Edellisessä luvussa mainittiin <a href="https://www.atlassian.com/git/tutorials/comparing-workflows/feature-branch-workflow">feature branchit</a>. Kyseessä on siis käytäntö, missä uudet ominaisuudet, esimerkiksi user storyn vaatima toiminnallisuus toteutetaan ensin omaan versionhallinnan haaraansa (branch) ja ominaisuuden valmistuttua haara mergetään pääkehityshaaraan (esim. masteriin).</p>

<p>Monet pitävät feature brancheja versionhallinnan käytön best practicena. Viime aikoina on kuitenkin monissa piireissä ruvettu pitämään feature branchaystä ikävänä käytänteenä, sillä se johtaa helposti pahoihin merge-konflikteihin, erityisesti jos branchit ovat pitkäikäisiä.</p>

<p>Seurauksena pienimuotoinen integraatiohelvetti, <em>merge hell</em> ja kehitystiimin normipäivä erityisesti sprintin lopussa alkaa muistuttaa seuraavaa</p>

<p><img src="http://localhost:4000/images/3-18.png" alt="" height="80px" /></p>

<p>Viime aikaisena suuntauksena on noussut esiin <a href="https://trunkbaseddevelopment.com/">trunk based development</a> missä pitkäikäisiä feature brancheja ei käytetä ollenkaan.</p>

<p>Kaikki muutokset tehdään suoraan pääkehityshaaraan, josta käytetään nimitystä <em>trunk</em>. Pääkehityshaara voi olla master tai joku erillinen branch käytännöistä riippuen. Ohjelmiston kustakin julkaistusta versiosta saatetaan tarvittaessa tehdä oma <em>release branch</em>.</p>

<p>Trunk-pohjainen kehitys pakottaa sovelluskehittäjät tekemään pieniä, nopeasti päähaaraan mergettäviä muutoksia. Trunk-pohjainen kehitys yhdistetään usein feature toggleihin, näin puolivalmiina olevia ominaisuuksia voidaan helposti ohjelmoida suoraan päähaaraan ja viedä tuotantoympäristöön ilman sovelluksen olemassa olevan toiminnallisuuden sotkemista.</p>

<p>Trunk-pohjainen kehitysmalli edellyttää sovelluskehittäjiltä erityisen suurta kuria ja systemaattisuutta. Feature brancheihin perustuva työskentely onkin aloittelijoiden tai vähemmän kurinalaisten kehittäjien kanssa turvallisempi toimintatapa kaikista ongelmistaan huolimatta.
Feature togglejen holtiton käyttö voi johtaa feature toggle helvettiin, eli suunnittelua ja systemaattisuutta todellakin tarvitaan.</p>

<p>Trunk-pohjaista kehitysmallia noudattavat monet maailman suurimmista internetpalveluista, esim. Google, Facebook ja Netflix.</p>

<h2 id="devops">DevOps</h2>

<p>Jatkuvan toimitusvalmiuden (Continuous delivery), jatkuvan käyttöönoton (Continuous deployment) ja tuotannossa testaamisen soveltaminen ei useimmiten ole ollenkaan suoraviivaista.</p>

<p>Perinteisesti yrityksissä on ollut tarkka erottelu sovelluskehittäjien (developers, dev) ja palvelinympäristöistä vastaavien järjestelmäylläpitäjien (operations, ops) välillä. On erittäin tavallista, että sovelluskehittäjät eivät pääse edes kirjautumaan tuotantopalvelimille ja sovellusten tuotantoon vieminen sekä esim. tuotantotietokantaan tehtävät skeeman päivitykset tapahtuvat ainoastaan ylläpitäjien toimesta.</p>

<p>Tälläisessä ympäristössä esim. continuous deploymentin harjoittaminen on lähes mahdotonta, tilanne ajautuukin helposti siihen, että tuotantopalvelimelle pystytään viemään uusia versioita vain harvoin, esimerkiksi ainoastaan 4 kertaa vuodessa.</p>

<p>Joustavammat toimintamallit uusien ominaisuuksien tuotantoon viemisessä vaativatkin täysin erilaista kulttuuria, sellaista, missä kehittäjät (dev) ja ylläpito (ops) työskentelevät tiiviissä yhteistyössä. Esim. sovelluskehittäjille tulee antaa tarvittava pääsy tuotantopalvelimelle tai Scrum-tiimiin tulee sijoittaa palvelinten ylläpidosta ja operoinnista huolehtivia ihmisiä. Toimintamallista missä dev ja ops työskentelevät tiiviisti yhdessä on käyttää nimeä <a href="https://en.wikipedia.org/wiki/DevOps">DevOps</a>.</p>

<p>DevOps on termi, joka on nykyään monin paikoin esillä, esimerkiksi työpaikkailmoituksissa voidaan arvostaa DevOps-taitoja tai jopa etsiä ihmistä DevOps-tiimiin. On myös myynnissä mitä erilaisimpia DevOps-työkaluja. On kuitenkin jossain määrin epäselvää mitä kukin tarkoittaa termillä DevOps.</p>

<p>Suurin osa (järkevistä) määritelmistä tarkoittaa DevOpsilla nimenomaan kehittäjien ja järjestelmäylläpidon yhteistä työnteon ja kommunikaation tapaa, jonka pyrkimyksenä on tehdä sovelluskehityksen aikaansaannosten käyttöönotto mahdollisimman sujuvaksi. Tämän takia onkin hyvä puhua DevOps-kulttuurista.</p>

<p>On olemassa joukko käsitteellisiä ja teknisiä työkaluja, jotka usein liitetään DevOps-tyyliseen työskentelyyn, esim.</p>

<ul>
  <li>automatisoitu testaus</li>
  <li>continuous deployment</li>
  <li>laskenta- ja tallennuskapasiteetin virtualisointi</li>
  <li>kontainerisointi (docker)</li>
  <li>infrastructure as code</li>
  <li>pilvipalveluna toimivat palvelimet ja sovellusympäristöt (PaaS, IaaS, SaaS)</li>
</ul>

<p>Monet edellisistä ovat kehittyneet vasta viimeisen 5-10 vuoden aikana ja täten mahdollistaneet DevOps:in helpomman soveltamisen.</p>

<p>Eräs tärkeimmistä DevOps:ia mahdollistavista asioista on ollut siirtyminen yhä enenevissä määrin käyttämään fyysisten palvelinten sijaan virtuaalisia ja pilvessä toimivia palvelimia. Pikkuhiljaa myös “palvelinrautaa” on ruvettu määrittelemään koodin avulla käsiteltävien konfiguraatiotiedostojen avulla. Englanniksi tästä ilmiöstä käytetään nimitystä <a href="https://en.wikipedia.org/wiki/Infrastructure_as_code">infrastructure as code</a>.</p>

<p>Palvelinten, tallennuskapasiteetin ja verkon konfiguraatioiden automatisoitu ohjelmallisesti tapahtuva hallinnointi on siis yleistynyt koko ajan. Palvelinten konfiguraatioita voidaan tallettaa versionhallintaan ja jopa testata. Sovelluskehitys ja ylläpito ovat alkaneet muistuttaa enemmän toisiaan kuin vanhoina (huonoina) aikoina. Tämä suuntaus on johtanut siihen, että sovelluskehittäjiltä on ruvettu pikkuhiljaa vaatimaan sellaisia taitoja, jotka olivat aiemmin selkeästi järjestelmäylläpitäjien vastuulla.</p>

<p>Työkalujen käyttöönotto ei kuitenkaan riitä, DevOps:in “tekeminen” lähtee pohjimmiltaan kulttuurisista tekijöistä, tiimirakenteista, sekä asioiden sallimisesta.</p>

<p>Scrumin ja ketterien menetelmien eräs tärkeimmistä periaatteista on tehdä kehitystiimeistä  <em>“cross functional”</em>, eli sellaisia, että ne sisältävät kaiken tietotaidon, joka tarvitaan saamaan user storyt valmiiksi definition of donen määrittelemällä laatutasolla. DevOps onkin eräs keino viedä ketteryyttä vielä askel pitemmälle, mahdollistaa se, että ketterät tiimit ovat todella cross functional ja että ne pystyvät viemään vaivattomasti toteuttamansa uudet toiminnallisuudet tuotantoympäristöön asti sekä jopa testaamaan ja operoimaan niitä tuotannossa.</p>

<p>Eräs parhaista DevOpsin määritelmistä on <a href="http://turnoff.us/geek/devops-explained/">Daniel Storin</a> käsialaa:</p>

<p><img src="http://localhost:4000/images/3-19.png" alt="" height="750px" /></p>

<h2 id="yhteenveto---ketterän-testauksen-nelikettä">Yhteenveto - ketterän testauksen nelikettä</h2>

<p>Ketterän testauksen kenttää voidaan jäsentää alunperin Brian Maric käsialaa olevan <a href="http://lisacrispin.com/2011/11/08/using-the-agile-testing-quadrants/">Agile Testing Quadrants</a> -kaavion avulla.</p>

<p><img src="http://localhost:4000/images/3-20.png" alt="" height="400px" /></p>

<p>Ketterän testauksen menetelmät voidaan siis jakaa neljään luokkaan (Q1…Q4) seuraavien dimensioiden suhteen:</p>
<ul>
  <li>business facing vs. technology facing, kohdistuuko testaus käyttäjän kokemaan toiminnallisuuteen vai enemmän ohjelmiston sisäisen toiminnallisuuden yksityiskohtiin</li>
  <li>supporting team vs. critique to the product, onko testien rooli toimia sovelluskehittäjien tukena vai varmistaa sovelluksen ulkoinen laatu</li>
</ul>

<p>Testit ovat suurelta osin automatisoitavissa, mutta esim. tutkiva testaaminen (exploratory testing) ja käyttäjän hyväksymistestaus (user acceptance testing) ovat luonteeltaan manuaalista työtä edellyttäviä.</p>

<p>Kaikilla “neljänneksillä” on oma roolinsa ja paikkansa ketterässä ohjelmistokehityksessä, ja on pitkälti kontekstisidonnaista missä suhteessa testaukseen ja laadunhallintaan käytettävissä olevat resurssit kannattaa kuhunkin neljännekseen kohdentaa.</p>

<p>Kaavio on jo hieman vanha, alunperin vuodelta 2003 joten se ei tunne vielä käsitettä tuotannossa testaaminen.</p>

<h2 id="loppupäätelmiä-testauksesta-ja-laadunhallinnasta">Loppupäätelmiä testauksesta ja laadunhallinnasta</h2>

<p>Tässä luvussa esitettävät asiat ovat osin omia, kokemuksen ja kirjallisuuden perusteella syntyneitä testaukseen liittyviä mielipiteitä.</p>

<p>Ketterissä menetelmissä kantavana teemana on arvon tuottaminen asiakkaalle ja tätä kannattaa käyttää ohjenuorana myös arvioitaessa mitä ja miten paljon projektissa tulisi testata. Testauksella ei ole itseisarvoista merkitystä, mutta testaamattomuus alkaa pian heikentää tuotteen laatua liikaa sekä hidastaa kehitysnopeutta radikaalilla tavalla. Joka tapauksessa testausta ja laadunhallintaa on tehtävä paljon ja toistuvasti, tämän takia testauksen automatisointi on yleensä pidemmällä tähtäimellä kannattavaa.</p>

<p>Testauksen automatisointi ei ole halpaa eikä helppoa. Väärin, väärään aikaan tai väärälle “tasolle” tehdyt automatisoidut testit voivat tuottaa enemmän harmia ja kustannuksia kuin hyötyä, erityisen suuri riski on käyttöliittymän kautta tehtävillä testeillä.</p>

<p>Jos ohjelmistossa on komponentteja, jotka tullaan ehkä poistamaan tai korvaamaan pian, on useimmiten järkevintä olla automatisoimatta niiden testejä. Esimerkiksi osassa 2 esitelty <a href="/osa2#vaatimusm%C3%A4%C3%A4rittely-2010-luvulla">MVP eli Minimal Viable Product</a> on karsittu toteutus, jonka avulla halutaan nopeasti selvittää, onko jokin ominaisuus ylipäätään käyttäjien kannalta arvokas. Jos MVP:n toteuttama ominaisuus osoittautuu tarpeettomaksi, se poistetaan järjestelmästä. MVP-periaattella tehty ominaisuus on siis useimmiten viisasta tehdä ilman testien automatisointia.</p>

<p>Ongelmallista kuitenkin usein on, että kertakäyttöiseksi tarkoitettu komponentti voi jäädä järjestelmään pitkäksikin aikaa, joskus jopa pysyvästi koska sitä “ei ole aikaa” toteuttaa kunnolla.</p>

<p>Kokonaan uutta ohjelmistoa tai komponenttia tehtäessä on yleensä järkevää antaa ohjelman rakenteen ensin stabiloitua ja tehdä kattavammat testit vasta myöhemmin. Komponenttien testattavuus kannattaa kuitenkin pitää koko ajan mielessä vaikka niille ei heti testejä tehtäisikään.</p>

<p>Oppikirjamääritelmän mukaista TDD:tä sovelletaan melko harvoin. Välillä kuitenkin TDD on hyödyllinen väline, esim. kehitettäessä rajapintoja, joita käyttäviä komponentteja ei ole vielä olemassa. Testit tekee samalla vaivalla kuin koodia käyttävän “pääohjelman”.</p>

<p>Kattavia yksikkötestejä ei kannata tehdä ohjelman kaikille luokille, usein vaihtoehto on tehdä integraatiotason testejä ohjelman isompien komponenttien rajapintoja vasten. Tällaiset testit pysyvät todennäköisemmin valideina komponenttien sisäisen rakenteen muuttuessa. Yksikkötestaus on hyödyllisimmillään kompleksia logiikkaa sisältävien luokkien testauksessa.</p>

<p>Vaikka käyttöliittymän läpi tehtävät järjestelmätason testit ovatkin riskialttiita käyttöliittymän mahdollisten muutosten takia, ovat ne usein hyödyllisin testien muoto, sillä toisin kuin esim. yksikkötestit, ne testaavat sovellusta kokonaisuudessaan (eli end to end).</p>

<p>Automaattisia testejä kannattaa kirjoittaa mahdollisimman paljon etenkin niiden järjestelmän komponenttien rajapintoihin, joita muokataan usein. Liian aikaisessa vaiheessa projektia tehtävät käyttöliittymän läpi suoritettavat testit saattavat aiheuttaa kohtuuttoman paljon ylläpitovaivaa, sillä testit hajoavat helposti pienistäkin käyttöliittymään tehtävistä muutoksista. Eli on syytä olla tarkkana sen suhteen missä vaiheessa käyttöliittymän läpi tapahtuva automatisoitu testaaminen kannattaa aloittaa.</p>

<p>Testitapausten kannattaa olla mahdollisimman paljon testattavan komponentin oikeiden käyttöskenaarioiden kaltaisia. Pelkkiä testauskattavuutta kasvattavia testejä on turha tehdä.</p>

<p>Testitapauksissa kannattaa käyttää mahdollisimman oikean kaltaista dataa, erityisesti järjestelmätason testeissä. Koodissa nimittäin lähes aina hajoaa jokin kun käytetään oikeaa dataa riippumatta siitä, miten hyvin testaus on suoritettu. Parasta onkin jos staging-ympäristössä on käytössä sama data kuin tuotantoympäristössä.</p>

<p>Ehdottomasti kaikkein tärkein asia sovelluksen laadunhallinnan kannalta on mahdollisimman usein tapahtuva tuotantoonvienti. Se taas edellyttää hyvin rakennettua deployment pipelineä, kohtuullista testauksen automatisointia ja helpottuu oleellisesti jos feature branchien sijaan käytetään trunk based development -periaatetta. Suosittelen lämpimästi että tuotantoonvienti tapahtuu niin usein kuin mahdollista, jopa useita kertoja päivässä. Tämä takaa yleensä sen, että pahoja integrointiongelmia ei synny, ja sovellukseen syntyvät regressiot havaitaan ja pystytään korjaamaan mahdollisimman nopeasti.</p>

  </div>

</article>
      </div>
    </main>

     <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading"></h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li>
             Ohjelmistotuotanto avoin yliopisto 2020 
          </li>
          <li>
            <a href="mailto:matti.luukkainen@helsinki.fi">matti.luukkainen@helsinki.fi</a>
          </li>
          <li>
            <a href="https://github.com/mluukkai"><span class="icon icon--github"><svg viewBox="0 0 16 16" width="16px" height="16px"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">mluukkai</span></a>

          </li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
           
        </ul>
      </div>

      <div class="footer-col footer-col-3">
          <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/">
            <img alt="Creative Commons -lisenssi" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/3.0/88x31.png"
            />
          </a>
          <br/> Materiaali on lisensoitu
          <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/">Creative Commons BY-NC-SA 3.0 -lisenssillä</a>.
      </div>
    </div>

  </div>

</footer>
  
  </body>

</html>
